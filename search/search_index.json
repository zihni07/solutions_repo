{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: A Detailed Exploration 1. Theoretical Foundation Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion can be analyzed by decomposing it into horizontal and vertical components. This type of motion is governed by kinematic equations and provides fundamental insights into physics and engineering applications. 1.1 Governing Equations The equations of motion follow from Newton's second law: \\[ F = ma \\] For projectile motion in two dimensions: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion due to gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: $ v_0 $ is the initial velocity, $ \\theta $ is the launch angle, $ g $ is the acceleration due to gravity, $ t $ is the time elapsed. The velocity components at any time $ t $ are: \\[ v_x = v_0 \\cos(\\theta) $$ $$ v_y = v_0 \\sin(\\theta) - g t \\] 1.2 Time of Flight The time when the projectile reaches the ground is found by setting $ y = 0 $: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] This equation provides insight into how the initial speed and angle affect the duration of flight. 1.3 Range of the Projectile The horizontal range is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range occurs at $ \\theta = 45^\\circ $ and is directly proportional to the square of the initial velocity. 1.4 Maximum Height The highest point $ y_{max} $ is found when $ v_y = 0 $: \\[ y_{max} = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] This formula helps determine the peak altitude reached by the projectile. 2. Analysis of Range Dependence 2.1 Effect of Launch Angle The range follows a sinusoidal relationship, peaking at $ 45^\\circ $. Complementary angles ($ \\theta $ and $ 90^\\circ - \\theta $) yield the same range. 2.2 Effect of Initial Velocity Range increases quadratically with initial speed. A higher initial velocity results in a longer trajectory and increased maximum height. 2.3 Effect of Gravity Stronger gravity shortens both range and time of flight. On celestial bodies with lower gravity (e.g., the Moon), projectiles travel much farther. 2.4 Effect of Launch Height A projectile launched from an elevated position stays airborne longer, extending its range. The additional term for height in the range equation introduces asymmetry in the trajectory. 3. Practical Applications 3.1 Sports Ballistics in football, basketball, and golf. Optimizing angles for maximum distance or height. 3.2 Engineering and Ballistics Missile trajectory calculations. Design of artillery and projectile-based defense systems. 3.3 Space Science Rocket launches and planetary landings. Escape velocity and orbital mechanics calculations. 4. Implementation in Python Below is a Python script that simulates projectile motion and plots various aspects of the motion: 4.1 Range vs. Launch Angle 4.2 Projectile Trajectory Simulation 4.3 Maximum Height vs. Launch Angle 4.4 Extending the Simulation Modify the code to include different gravitational accelerations. Introduce air resistance for a more realistic trajectory. Simulate varying launch heights. 5. Limitations and Extensions 5.1 Assumptions in the Ideal Model Neglecting Air Resistance: In reality, drag alters the trajectory. Ignoring Wind Effects: Crosswinds and tailwinds significantly impact real-world projectile motion. Constant Gravity: Gravity slightly varies with altitude, especially in high-altitude launches. 5.2 Advanced Considerations Numerical Simulations: Solving differential equations for motion with drag. Uneven Terrain: Adjusting the impact location based on varying elevation. Multi-Stage Projectiles: Studying objects with varying thrust and mass changes (e.g., rockets). This Markdown document serves as a comprehensive introduction to projectile motion, its equations, analysis, and Python simulation. It also provides avenues for further research and computational modeling in real-world applications.","title":"Projectile Motion: A Detailed Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-a-detailed-exploration","text":"","title":"Projectile Motion: A Detailed Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion can be analyzed by decomposing it into horizontal and vertical components. This type of motion is governed by kinematic equations and provides fundamental insights into physics and engineering applications.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations","text":"The equations of motion follow from Newton's second law: \\[ F = ma \\] For projectile motion in two dimensions: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion due to gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: $ v_0 $ is the initial velocity, $ \\theta $ is the launch angle, $ g $ is the acceleration due to gravity, $ t $ is the time elapsed. The velocity components at any time $ t $ are: \\[ v_x = v_0 \\cos(\\theta) $$ $$ v_y = v_0 \\sin(\\theta) - g t \\]","title":"1.1 Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time when the projectile reaches the ground is found by setting $ y = 0 $: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] This equation provides insight into how the initial speed and angle affect the duration of flight.","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-of-the-projectile","text":"The horizontal range is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range occurs at $ \\theta = 45^\\circ $ and is directly proportional to the square of the initial velocity.","title":"1.3 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-maximum-height","text":"The highest point $ y_{max} $ is found when $ v_y = 0 $: \\[ y_{max} = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] This formula helps determine the peak altitude reached by the projectile.","title":"1.4 Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-range-dependence","text":"","title":"2. Analysis of Range Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-effect-of-launch-angle","text":"The range follows a sinusoidal relationship, peaking at $ 45^\\circ $. Complementary angles ($ \\theta $ and $ 90^\\circ - \\theta $) yield the same range.","title":"2.1 Effect of Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-effect-of-initial-velocity","text":"Range increases quadratically with initial speed. A higher initial velocity results in a longer trajectory and increased maximum height.","title":"2.2 Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-effect-of-gravity","text":"Stronger gravity shortens both range and time of flight. On celestial bodies with lower gravity (e.g., the Moon), projectiles travel much farther.","title":"2.3 Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-effect-of-launch-height","text":"A projectile launched from an elevated position stays airborne longer, extending its range. The additional term for height in the range equation introduces asymmetry in the trajectory.","title":"2.4 Effect of Launch Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-sports","text":"Ballistics in football, basketball, and golf. Optimizing angles for maximum distance or height.","title":"3.1 Sports"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-engineering-and-ballistics","text":"Missile trajectory calculations. Design of artillery and projectile-based defense systems.","title":"3.2 Engineering and Ballistics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-space-science","text":"Rocket launches and planetary landings. Escape velocity and orbital mechanics calculations.","title":"3.3 Space Science"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"Below is a Python script that simulates projectile motion and plots various aspects of the motion:","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#41-range-vs-launch-angle","text":"","title":"4.1 Range vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#42-projectile-trajectory-simulation","text":"","title":"4.2 Projectile Trajectory Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#43-maximum-height-vs-launch-angle","text":"","title":"4.3 Maximum Height vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#44-extending-the-simulation","text":"Modify the code to include different gravitational accelerations. Introduce air resistance for a more realistic trajectory. Simulate varying launch heights.","title":"4.4 Extending the Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#51-assumptions-in-the-ideal-model","text":"Neglecting Air Resistance: In reality, drag alters the trajectory. Ignoring Wind Effects: Crosswinds and tailwinds significantly impact real-world projectile motion. Constant Gravity: Gravity slightly varies with altitude, especially in high-altitude launches.","title":"5.1 Assumptions in the Ideal Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#52-advanced-considerations","text":"Numerical Simulations: Solving differential equations for motion with drag. Uneven Terrain: Adjusting the impact location based on varying elevation. Multi-Stage Projectiles: Studying objects with varying thrust and mass changes (e.g., rockets). This Markdown document serves as a comprehensive introduction to projectile motion, its equations, analysis, and Python simulation. It also provides avenues for further research and computational modeling in real-world applications.","title":"5.2 Advanced Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum: A Comprehensive Study 1. Theoretical Foundation The forced damped pendulum is a nonlinear dynamical system governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum. 1.1 Approximate Solutions for Small Angles For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator with well-known resonance conditions: \\[ \\omega \\approx \\omega_0 \\] At resonance, oscillation amplitude can increase significantly if damping is low. 1.2 Energy Analysis The total energy of the pendulum system is given by: \\[ E = \\frac{1}{2} m L^2 \\left( \\dot{\\theta}^2 \\right) + mgL(1 - \\cos\\theta) \\] Energy dissipation occurs due to damping, while the driving force periodically injects energy. 2. Analysis of Dynamics The system's behavior varies based on damping, forcing, and initial conditions: Low damping, weak forcing: Regular oscillations similar to simple harmonic motion. Moderate forcing and damping: Quasi-periodic and periodic oscillations. High forcing and low damping: Transition to chaotic motion. 2.1 Phase Space Analysis The pendulum's state in phase space ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) reveals: - Periodic motion: Closed loops. - Chaotic motion: Complex, fractal-like structures. 2.2 Poincar\u00e9 Sections By sampling phase space at discrete intervals, Poincar\u00e9 sections illustrate order-to-chaos transitions. 2.3 Bifurcation and Chaos By varying \\(A\\) , the system undergoes period-doubling cascades, leading to chaotic regimes. 3. Practical Applications Engineering: Suspension bridges, vibration control. Energy Harvesting: Mechanical-to-electrical conversion. Biomechanics: Gait dynamics, neural rhythms. Electrical Circuits: Analogous behavior in driven RLC circuits. 4. Implementation in Python 4.1 Simulating the Forced Damped Pendulum 4.2 Phase Space Plot 4.3 Poincar\u00e9 Section 4.4 Bifurcation Diagram 5. Limitations and Future Research 5.1 Model Limitations Neglecting complex damping : Real-world damping is nonlinear. Non-periodic forcing : More general forcing functions introduce richer dynamics. Multi-body interactions : Coupled pendulums exhibit additional complexity. 5.2 Future Research Directions Lyapunov exponent analysis for chaos detection. Stochastic forcing : Effects of noise and random perturbations. Higher-order bifurcation studies in advanced dynamical systems. Conclusion This extended analysis of the forced damped pendulum provides theoretical insights, computational tools, and real-world applications. Using Python simulations, we explore resonance, chaos, and bifurcations, demonstrating the pendulum\u2019s role as a fundamental nonlinear system in physics and engineering.","title":"Forced Damped Pendulum: A Comprehensive Study"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-a-comprehensive-study","text":"","title":"Forced Damped Pendulum: A Comprehensive Study"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear dynamical system governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-approximate-solutions-for-small-angles","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator with well-known resonance conditions: \\[ \\omega \\approx \\omega_0 \\] At resonance, oscillation amplitude can increase significantly if damping is low.","title":"1.1 Approximate Solutions for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-energy-analysis","text":"The total energy of the pendulum system is given by: \\[ E = \\frac{1}{2} m L^2 \\left( \\dot{\\theta}^2 \\right) + mgL(1 - \\cos\\theta) \\] Energy dissipation occurs due to damping, while the driving force periodically injects energy.","title":"1.2 Energy Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The system's behavior varies based on damping, forcing, and initial conditions: Low damping, weak forcing: Regular oscillations similar to simple harmonic motion. Moderate forcing and damping: Quasi-periodic and periodic oscillations. High forcing and low damping: Transition to chaotic motion.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-phase-space-analysis","text":"The pendulum's state in phase space ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) reveals: - Periodic motion: Closed loops. - Chaotic motion: Complex, fractal-like structures.","title":"2.1 Phase Space Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-poincare-sections","text":"By sampling phase space at discrete intervals, Poincar\u00e9 sections illustrate order-to-chaos transitions.","title":"2.2 Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-bifurcation-and-chaos","text":"By varying \\(A\\) , the system undergoes period-doubling cascades, leading to chaotic regimes.","title":"2.3 Bifurcation and Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Engineering: Suspension bridges, vibration control. Energy Harvesting: Mechanical-to-electrical conversion. Biomechanics: Gait dynamics, neural rhythms. Electrical Circuits: Analogous behavior in driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-in-python","text":"","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-simulating-the-forced-damped-pendulum","text":"","title":"4.1 Simulating the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-phase-space-plot","text":"","title":"4.2 Phase Space Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-poincare-section","text":"","title":"4.3 Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#44-bifurcation-diagram","text":"","title":"4.4 Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-future-research","text":"","title":"5. Limitations and Future Research"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-model-limitations","text":"Neglecting complex damping : Real-world damping is nonlinear. Non-periodic forcing : More general forcing functions introduce richer dynamics. Multi-body interactions : Coupled pendulums exhibit additional complexity.","title":"5.1 Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-future-research-directions","text":"Lyapunov exponent analysis for chaos detection. Stochastic forcing : Effects of noise and random perturbations. Higher-order bifurcation studies in advanced dynamical systems.","title":"5.2 Future Research Directions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This extended analysis of the forced damped pendulum provides theoretical insights, computational tools, and real-world applications. Using Python simulations, we explore resonance, chaos, and bifurcations, demonstrating the pendulum\u2019s role as a fundamental nonlinear system in physics and engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of its semi-major axis (orbital radius in circular orbits). This relationship is fundamental in celestial mechanics, helping astronomers determine planetary motions and gravitational interactions. Understanding this law allows us to predict satellite orbits, planetary system behavior, and even exoplanetary systems. Kepler\u2019s Third Law Derivation For a circular orbit, the centripetal force required to maintain motion is provided by gravitational attraction: \\[ F_c = \\frac{m v^2}{r} \\] \\[ F_g = \\frac{G M m}{r^2} \\] Equating these forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Since velocity \\(v\\) is given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\(v\\) in the equation: \\[ \\frac{m (4 \\pi^2 r^2)}{T^2 r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) and rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This confirms Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] where \\(G\\) is the gravitational constant, \\(M\\) is the central body\u2019s mass, \\(T\\) is the orbital period, and \\(r\\) is the orbital radius. Implications in Astronomy Used to calculate planetary masses and distances. Helps determine exoplanet properties. Crucial for spacecraft mission planning and satellite deployment. Real-World Examples Moon's Orbit Around Earth Given Earth\u2019s mass ( \\(5.972 \\times 10^{24}\\) kg) and the Moon\u2019s average orbital radius ( \\(3.84 \\times 10^8\\) m), Kepler\u2019s Law predicts the Moon\u2019s orbital period correctly (~27.3 days). Planets in the Solar System The relationship holds true for all planets orbiting the Sun, reinforcing its universal applicability. Computational Model in Python The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law graphically. ![ ]![alt ! Extension to Elliptical Orbits Kepler\u2019s Third Law extends to elliptical orbits, where the semi-major axis replaces the orbital radius: \\[ T^2 \\propto a^3 \\] This generalization helps describe non-circular planetary orbits and spacecraft trajectories. Conclusion Kepler\u2019s Third Law remains a powerful tool in celestial mechanics, aiding in planetary studies, exoplanet discovery, and space mission design. Its mathematical elegance bridges theoretical physics and real-world applications.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of its semi-major axis (orbital radius in circular orbits). This relationship is fundamental in celestial mechanics, helping astronomers determine planetary motions and gravitational interactions. Understanding this law allows us to predict satellite orbits, planetary system behavior, and even exoplanetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-derivation","text":"For a circular orbit, the centripetal force required to maintain motion is provided by gravitational attraction: \\[ F_c = \\frac{m v^2}{r} \\] \\[ F_g = \\frac{G M m}{r^2} \\] Equating these forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Since velocity \\(v\\) is given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\(v\\) in the equation: \\[ \\frac{m (4 \\pi^2 r^2)}{T^2 r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) and rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This confirms Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] where \\(G\\) is the gravitational constant, \\(M\\) is the central body\u2019s mass, \\(T\\) is the orbital period, and \\(r\\) is the orbital radius.","title":"Kepler\u2019s Third Law Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Used to calculate planetary masses and distances. Helps determine exoplanet properties. Crucial for spacecraft mission planning and satellite deployment.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth Given Earth\u2019s mass ( \\(5.972 \\times 10^{24}\\) kg) and the Moon\u2019s average orbital radius ( \\(3.84 \\times 10^8\\) m), Kepler\u2019s Law predicts the Moon\u2019s orbital period correctly (~27.3 days). Planets in the Solar System The relationship holds true for all planets orbiting the Sun, reinforcing its universal applicability.","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model-in-python","text":"The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law graphically. ![ ]![alt !","title":"Computational Model in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law extends to elliptical orbits, where the semi-major axis replaces the orbital radius: \\[ T^2 \\propto a^3 \\] This generalization helps describe non-circular planetary orbits and spacecraft trajectories.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law remains a powerful tool in celestial mechanics, aiding in planetary studies, exoplanet discovery, and space mission design. Its mathematical elegance bridges theoretical physics and real-world applications.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Cosmic Velocities Definitions First Cosmic Velocity (Orbital Velocity): The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius. This velocity ensures that the centrifugal force due to orbital motion balances the gravitational pull. Second Cosmic Velocity (Escape Velocity): The minimum velocity required to escape a celestial body's gravitational pull without further propulsion. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. At this velocity, the kinetic energy equals the gravitational potential energy, allowing the object to escape indefinitely. Third Cosmic Velocity (Solar System Escape Velocity: The velocity required to escape the gravitational influence of the entire solar system. It depends on the escape velocity from Earth and the Sun\u2019s influence: $$ v_3 = \\sqrt{v_2^2 + v_{esc,\\odot}^2} $$ Where \\(v_{esc,\\odot}\\) is the escape velocity from the Sun. This is crucial for interstellar missions and deep space exploration. Mathematical Derivation To derive the escape velocity, consider the conservation of energy: \\[ \\text{Total Energy} = \\text{Kinetic Energy} + \\text{Gravitational Potential Energy} \\] \\[ \\frac{1}{2} m v^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] This equation applies to any celestial body, with variations in mass and radius affecting the velocity required for escape. Computational Analysis The following Python script calculates and visualizes these velocities for Earth, Mars, and Jupiter. Importance in Space Exploration Satellites & Space Stations: The first cosmic velocity is crucial for placing satellites in stable orbits. The International Space Station (ISS) orbits Earth at approximately 7.66 km/s. Lunar & Interplanetary Missions: The second cosmic velocity is essential for missions to the Moon, Mars, and beyond. Apollo missions had to exceed Earth's escape velocity to reach the Moon. Interstellar Travel: The third cosmic velocity is relevant for long-term space exploration. Probes like Voyager 1 and 2 have achieved solar system escape velocity and are currently traveling into interstellar space. Conclusion Escape and cosmic velocities define fundamental thresholds in celestial mechanics, guiding modern space exploration efforts. Understanding these principles allows for more efficient mission planning and technological advancements in space travel. They provide the foundation for future endeavors, including planetary colonization and interstellar exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-definitions","text":"First Cosmic Velocity (Orbital Velocity): The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius. This velocity ensures that the centrifugal force due to orbital motion balances the gravitational pull. Second Cosmic Velocity (Escape Velocity): The minimum velocity required to escape a celestial body's gravitational pull without further propulsion. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. At this velocity, the kinetic energy equals the gravitational potential energy, allowing the object to escape indefinitely. Third Cosmic Velocity (Solar System Escape Velocity: The velocity required to escape the gravitational influence of the entire solar system. It depends on the escape velocity from Earth and the Sun\u2019s influence: $$ v_3 = \\sqrt{v_2^2 + v_{esc,\\odot}^2} $$ Where \\(v_{esc,\\odot}\\) is the escape velocity from the Sun. This is crucial for interstellar missions and deep space exploration.","title":"Cosmic Velocities Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation","text":"To derive the escape velocity, consider the conservation of energy: \\[ \\text{Total Energy} = \\text{Kinetic Energy} + \\text{Gravitational Potential Energy} \\] \\[ \\frac{1}{2} m v^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] This equation applies to any celestial body, with variations in mass and radius affecting the velocity required for escape.","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-analysis","text":"The following Python script calculates and visualizes these velocities for Earth, Mars, and Jupiter.","title":"Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Satellites & Space Stations: The first cosmic velocity is crucial for placing satellites in stable orbits. The International Space Station (ISS) orbits Earth at approximately 7.66 km/s. Lunar & Interplanetary Missions: The second cosmic velocity is essential for missions to the Moon, Mars, and beyond. Apollo missions had to exceed Earth's escape velocity to reach the Moon. Interstellar Travel: The third cosmic velocity is relevant for long-term space exploration. Probes like Voyager 1 and 2 have achieved solar system escape velocity and are currently traveling into interstellar space.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape and cosmic velocities define fundamental thresholds in celestial mechanics, guiding modern space exploration efforts. Understanding these principles allows for more efficient mission planning and technological advancements in space travel. They provide the foundation for future endeavors, including planetary colonization and interstellar exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving spacecraft near Earth, its trajectory is influenced by its initial velocity and the gravitational pull of Earth. Understanding these trajectories is crucial for various space missions, including satellite deployment, reentry planning, and interplanetary travel. This study aims to analyze possible trajectories, simulate them numerically, and visualize the results. Governing Equations The motion of the payload is governed by Newton's Law of Gravitation and Newton's Second Law of Motion: \\[ F = \\frac{G M_{earth} m}{r^2} \\] where: \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2), \\(M_{earth}\\) is Earth's mass ( \\(5.972 \\times 10^{24}\\) kg), \\(r\\) is the radial distance from Earth's center, \\(m\\) is the mass of the payload. Using Newton\u2019s Second Law ( \\(F = ma\\) ), we derive the equations of motion in two-dimensional Cartesian coordinates: \\[ a_x = -\\frac{G M_{earth} x}{r^3}, \\quad a_y = -\\frac{G M_{earth} y}{r^3} \\] where \\((x, y)\\) represents the position of the payload. Types of Possible Trajectories Circular Orbit : If the velocity of the payload is precisely the orbital velocity for its altitude, it will move in a circular orbit around Earth. Elliptical Orbit : When the velocity is below escape velocity but not equal to circular velocity, the payload follows an elliptical orbit. Parabolic Trajectory : If the payload\u2019s velocity is exactly equal to escape velocity ( \\(v_{esc} = \\sqrt{2 G M_{earth} / r}\\) ), it will follow a parabolic trajectory, escaping Earth's gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence completely. Suborbital Trajectory : If the velocity is too low, the payload will follow a ballistic trajectory and reenter Earth's atmosphere. Numerical Simulation We employ the Runge-Kutta method to integrate these equations and determine the payload's trajectory. Python Implementation Additional Simulations Effect of Atmospheric Drag Conclusion By simulating the motion of a payload released near Earth, we gain insights into orbital mechanics and space mission design. This study provides a computational approach to predicting different possible trajectories based on initial conditions. Further analysis can incorporate atmospheric drag, gravitational perturbations, and interactions with other celestial bodies. ```","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving spacecraft near Earth, its trajectory is influenced by its initial velocity and the gravitational pull of Earth. Understanding these trajectories is crucial for various space missions, including satellite deployment, reentry planning, and interplanetary travel. This study aims to analyze possible trajectories, simulate them numerically, and visualize the results.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The motion of the payload is governed by Newton's Law of Gravitation and Newton's Second Law of Motion: \\[ F = \\frac{G M_{earth} m}{r^2} \\] where: \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2), \\(M_{earth}\\) is Earth's mass ( \\(5.972 \\times 10^{24}\\) kg), \\(r\\) is the radial distance from Earth's center, \\(m\\) is the mass of the payload. Using Newton\u2019s Second Law ( \\(F = ma\\) ), we derive the equations of motion in two-dimensional Cartesian coordinates: \\[ a_x = -\\frac{G M_{earth} x}{r^3}, \\quad a_y = -\\frac{G M_{earth} y}{r^3} \\] where \\((x, y)\\) represents the position of the payload.","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"Circular Orbit : If the velocity of the payload is precisely the orbital velocity for its altitude, it will move in a circular orbit around Earth. Elliptical Orbit : When the velocity is below escape velocity but not equal to circular velocity, the payload follows an elliptical orbit. Parabolic Trajectory : If the payload\u2019s velocity is exactly equal to escape velocity ( \\(v_{esc} = \\sqrt{2 G M_{earth} / r}\\) ), it will follow a parabolic trajectory, escaping Earth's gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence completely. Suborbital Trajectory : If the velocity is too low, the payload will follow a ballistic trajectory and reenter Earth's atmosphere.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"We employ the Runge-Kutta method to integrate these equations and determine the payload's trajectory.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#additional-simulations","text":"","title":"Additional Simulations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#effect-of-atmospheric-drag","text":"","title":"Effect of Atmospheric Drag"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By simulating the motion of a payload released near Earth, we gain insights into orbital mechanics and space mission design. This study provides a computational approach to predicting different possible trajectories based on initial conditions. Further analysis can incorporate atmospheric drag, gravitational perturbations, and interactions with other celestial bodies. ```","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Simulation Introduction Interference occurs when waves from different sources overlap, forming unique patterns. On a water surface, this can be seen when ripples from different points meet, creating interference patterns. Understanding these patterns helps in visualizing wave behavior and the principles of constructive and destructive interference. Problem Statement We aim to analyze interference patterns formed due to the superposition of waves emitted from point sources arranged at the vertices of a chosen regular polygon. This will provide insights into wave interactions and phase relationships. Mathematical Model A circular wave from a point source at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos (kr - \\omega t + \\phi) \\] where: - \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, - \\(\\phi\\) is the initial phase. For multiple wave sources, the total displacement at any point is given by the superposition principle: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\(N\\) is the number of sources. Implementation in Python We use Python with Matplotlib and NumPy to simulate wave interference patterns. The approach includes: 1. Choosing a regular polygon (triangle, square, pentagon, etc.). 2. Placing wave sources at its vertices. 3. Calculating the resultant wave field by summing individual waves. 4. Visualizing the interference pattern. Results and Observations Different polygons produce distinct interference patterns. Regions of constructive interference (bright spots) and destructive interference (dark spots) are clearly visible. Increasing the number of sources leads to more complex patterns. A 3D visualization gives a more intuitive understanding of amplitude variations. Conclusion This simulation helps in understanding wave superposition in a visually intuitive way. The principle extends to many physical phenomena, including optics, acoustics, and quantum mechanics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-simulation","text":"","title":"Wave Interference Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"Interference occurs when waves from different sources overlap, forming unique patterns. On a water surface, this can be seen when ripples from different points meet, creating interference patterns. Understanding these patterns helps in visualizing wave behavior and the principles of constructive and destructive interference.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We aim to analyze interference patterns formed due to the superposition of waves emitted from point sources arranged at the vertices of a chosen regular polygon. This will provide insights into wave interactions and phase relationships.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"A circular wave from a point source at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos (kr - \\omega t + \\phi) \\] where: - \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, - \\(\\phi\\) is the initial phase. For multiple wave sources, the total displacement at any point is given by the superposition principle: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\(N\\) is the number of sources.","title":"Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#implementation-in-python","text":"We use Python with Matplotlib and NumPy to simulate wave interference patterns. The approach includes: 1. Choosing a regular polygon (triangle, square, pentagon, etc.). 2. Placing wave sources at its vertices. 3. Calculating the resultant wave field by summing individual waves. 4. Visualizing the interference pattern.","title":"Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-and-observations","text":"Different polygons produce distinct interference patterns. Regions of constructive interference (bright spots) and destructive interference (dark spots) are clearly visible. Increasing the number of sources leads to more complex patterns. A 3D visualization gives a more intuitive understanding of amplitude variations.","title":"Results and Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation helps in understanding wave superposition in a visually intuitive way. The principle extends to many physical phenomena, including optics, acoustics, and quantum mechanics.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism \u2014 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as: \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories arising from this force, gaining both qualitative and quantitative insights into real-world systems. Task 1. Exploration of Applications Identify systems where the Lorentz force plays a key role: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., Tokamaks) Earth's magnetosphere interactions with solar wind Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling particle motion, such as: Velocity selection in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields (velocity selector) Magnetic bottle traps for confining plasmas 2. Simulating Particle Motion Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. A uniform electric field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate various particle motions: Circular motion Helical motion Linear acceleration Drift motion in crossed fields 3. Parameter Exploration Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge ( \\(q\\) ) and mass ( \\(m\\) ) of the particle Observe how these parameters influence: Larmor radius Cyclotron frequency Drift velocity 4. Visualization Create labeled 2D and 3D plots: X vs Y, X vs Z, and 3D trajectories Highlight key physical phenomena: Larmor radius Cyclotron frequency \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity Solution Equations of Motion The Lorentz force provides the basis for the equations of motion: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] Numerical Integration We will use Euler's method for simplicity, but Runge-Kutta 4th order (RK4) is preferable for higher accuracy. Python Code (Euler Method) Additional: Runge-Kutta Method Observations Theoretical Background Cyclotron Frequency \\(\\omega_c\\) : $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius \\(r_L\\) : $$ r_L = \\frac{mv_\\perp}{qB} $$ Where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) . Simulation Insights Pure magnetic fields: Particles move in perfect circles (or helices if there is a \\(v_z\\) component). Crossed fields: Particles drift at velocity \\(\\mathbf{v}_d\\) : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Particle mass and charge directly affect the radius and frequency of rotation. Deliverables Summary A Python notebook implementing both Euler and Runge-Kutta methods. Simulations for: Uniform \\(\\mathbf{B}\\) fields Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields Clear and well-labeled plots. Discussion of practical relevance to cyclotrons, plasma traps, and space physics. Hints and Resources For better precision, use adaptive time-stepping methods. Explore relativistic effects for ultra-fast particles using the Lorentz factor \\(\\gamma\\) . Extend simulations to non-uniform fields or magnetic mirrors. Key References: - Griffiths, D.J., Introduction to Electrodynamics - Birdsall and Langdon, Plasma Physics via Computer Simulation Conclusion By applying the Lorentz force in numerical simulations, we develop an intuitive and quantitative understanding of charged particle motion in electromagnetic fields. These principles underpin technologies from particle accelerators to magnetic plasma confinement systems, forming a bridge between theoretical electromagnetism and cutting-edge applications.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-simulating-the-effects-of-the-lorentz-force","text":"","title":"Electromagnetism \u2014 Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories arising from this force, gaining both qualitative and quantitative insights into real-world systems.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Identify systems where the Lorentz force plays a key role: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., Tokamaks) Earth's magnetosphere interactions with solar wind Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling particle motion, such as: Velocity selection in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields (velocity selector) Magnetic bottle traps for confining plasmas","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. A uniform electric field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate various particle motions: Circular motion Helical motion Linear acceleration Drift motion in crossed fields","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge ( \\(q\\) ) and mass ( \\(m\\) ) of the particle Observe how these parameters influence: Larmor radius Cyclotron frequency Drift velocity","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Create labeled 2D and 3D plots: X vs Y, X vs Z, and 3D trajectories Highlight key physical phenomena: Larmor radius Cyclotron frequency \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#solution","text":"","title":"Solution"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"The Lorentz force provides the basis for the equations of motion: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\]","title":"Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-integration","text":"We will use Euler's method for simplicity, but Runge-Kutta 4th order (RK4) is preferable for higher accuracy.","title":"Numerical Integration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-euler-method","text":"","title":"Python Code (Euler Method)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#additional-runge-kutta-method","text":"","title":"Additional: Runge-Kutta Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations","text":"","title":"Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theoretical-background","text":"Cyclotron Frequency \\(\\omega_c\\) : $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius \\(r_L\\) : $$ r_L = \\frac{mv_\\perp}{qB} $$ Where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) .","title":"Theoretical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-insights","text":"Pure magnetic fields: Particles move in perfect circles (or helices if there is a \\(v_z\\) component). Crossed fields: Particles drift at velocity \\(\\mathbf{v}_d\\) : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Particle mass and charge directly affect the radius and frequency of rotation.","title":"Simulation Insights"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables-summary","text":"A Python notebook implementing both Euler and Runge-Kutta methods. Simulations for: Uniform \\(\\mathbf{B}\\) fields Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields Clear and well-labeled plots. Discussion of practical relevance to cyclotrons, plasma traps, and space physics.","title":"Deliverables Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"For better precision, use adaptive time-stepping methods. Explore relativistic effects for ultra-fast particles using the Lorentz factor \\(\\gamma\\) . Extend simulations to non-uniform fields or magnetic mirrors. Key References: - Griffiths, D.J., Introduction to Electrodynamics - Birdsall and Langdon, Plasma Physics via Computer Simulation","title":"Hints and Resources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"By applying the Lorentz force in numerical simulations, we develop an intuitive and quantitative understanding of charged particle motion in electromagnetic fields. These principles underpin technologies from particle accelerators to magnetic plasma confinement systems, forming a bridge between theoretical electromagnetism and cutting-edge applications.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Calculation Using Graph Theory Introduction Calculating equivalent resistance in complex circuits can be tedious using traditional methods. Graph theory provides a structured and powerful approach: Nodes represent junctions where multiple components connect. Edges represent resistors, with weights equal to resistance values. By representing circuits as graphs, we gain access to efficient algorithms that simplify complex networks systematically. Iterative application of series and parallel reductions allows us to simplify any network into a single resistance value, regardless of its complexity. Applications of this method span: - Electrical circuit simulation software - Optimization in microchip design - Educational tools for teaching electrical engineering - Automated design verification Key Formulas Series combination : \\[ R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n \\] Series resistors add directly because current must pass through each sequentially. Parallel combination : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Parallel resistors share current across multiple paths, leading to a reduced overall resistance. Algorithm Overview The algorithm proceeds with the following steps: Input : A weighted undirected graph \\(G\\) where: Nodes = circuit junctions Edges = resistors, with weight = resistance in ohms Identify reduction opportunities : Series reduction : Look for nodes with degree 2 that are not the start or end node. Parallel reduction : Look for multiple edges between the same two nodes. Apply simplifications : Series rule : Replace a two-edge chain with a single edge whose resistance is the sum of the two. Parallel rule : Replace multiple parallel edges with a single equivalent resistance using the parallel formula. Repeat until only the start and end nodes remain connected directly by a single equivalent resistance. Output : The final equivalent resistance value between the designated start and end nodes. Pseudocode function simplify_circuit(G, start, end): while G has more than two nodes: for each node v not in {start, end}: if degree(v) == 2: neighbors = [u, w] if (u,v) and (v,w) not forming a cycle: combine series resistance: R = R(u,v) + R(v,w) remove v, add edge (u,w) with resistance R for each pair of nodes (u, v): if multiple edges between u and v: combine parallel resistances: 1 / R_total = sum(1 / R_i for each edge R_i between u and v) replace edges with single edge of resistance R_total return resistance between start and end Notes: - Cycles must be carefully checked to avoid incorrect series reductions. - Parallel combinations must consider all possible parallel paths. Python Implementation import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: reduced = False # Simplify series connections for node in list(G.nodes): if node in (start, end): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if not nx.has_path(G, u, v) or (node in nx.shortest_path(G, u, v)[1:-1]): r1 = G[u][node]['resistance'] r2 = G[v][node]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) reduced = True break if reduced: continue # Simplify parallel connections for u, v in list(G.edges): parallel_edges = G.get_edge_data(u, v) if isinstance(parallel_edges, dict) and len(parallel_edges) > 1: resistances = [data['resistance'] for key, data in parallel_edges.items()] r_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)]*len(resistances)) G.add_edge(u, v, resistance=r_parallel) reduced = True break if not reduced: break return G[start][end]['resistance'] Important Implementation Details The graph must correctly store resistance on edges. Parallel simplification assumes multiple edges between two nodes. This algorithm assumes no complicated sub-circuits like bridges (Wheatstone Bridge) without preprocessing. Example Usage # Create a graph G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=5) G.add_edge('B', 'D', resistance=6) # Compute equivalent resistance between A and D req = simplify_circuit(G, 'A', 'D') print(f\"Equivalent resistance between A and D: {req} ohms\") Test Examples 1. Simple Series Connection Two resistors in series: \\(2 \\Omega\\) + \\(3 \\Omega\\) = \\(5 \\Omega\\) Total equivalent resistance: \\[ R_{\\text{eq}} = 5 \\Omega \\] 2. Simple Parallel Connection Two resistors in parallel: \\[ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} \\] \\[ \\frac{1}{R} = \\frac{5}{12} \\] Thus, \\[ R = 2.4 \\Omega \\] 3. Complex Graph (Nested Combination) Multiple series and parallel configurations are detected automatically. No manual intervention is required for nested groups. Efficiency Analysis Time Complexity : Series reduction: \\(O(V)\\) per iteration. Parallel reduction: \\(O(E^2)\\) if naive checking. Space Complexity : Storing the graph requires \\(O(V + E)\\) space. Potential Improvements Graph Compression : Use data structures like Union-Find to manage node merging. Cycle Detection Optimization : Faster cycle checks can reduce redundant searches. Parallel Computation : Apply parallelism to identify multiple reduction sites at once. Conclusion Using graph theory , complex electrical circuits can be programmatically simplified. This method provides a powerful framework for: - Rapid analysis of large circuits. - Integration into electrical simulation software. - Automated design and optimization of electronic systems. Future work could extend this approach to dynamically changing circuits, non-linear components, and real-time optimization.","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-calculation-using-graph-theory","text":"","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating equivalent resistance in complex circuits can be tedious using traditional methods. Graph theory provides a structured and powerful approach: Nodes represent junctions where multiple components connect. Edges represent resistors, with weights equal to resistance values. By representing circuits as graphs, we gain access to efficient algorithms that simplify complex networks systematically. Iterative application of series and parallel reductions allows us to simplify any network into a single resistance value, regardless of its complexity. Applications of this method span: - Electrical circuit simulation software - Optimization in microchip design - Educational tools for teaching electrical engineering - Automated design verification","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-formulas","text":"Series combination : \\[ R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n \\] Series resistors add directly because current must pass through each sequentially. Parallel combination : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Parallel resistors share current across multiple paths, leading to a reduced overall resistance.","title":"Key Formulas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"The algorithm proceeds with the following steps: Input : A weighted undirected graph \\(G\\) where: Nodes = circuit junctions Edges = resistors, with weight = resistance in ohms Identify reduction opportunities : Series reduction : Look for nodes with degree 2 that are not the start or end node. Parallel reduction : Look for multiple edges between the same two nodes. Apply simplifications : Series rule : Replace a two-edge chain with a single edge whose resistance is the sum of the two. Parallel rule : Replace multiple parallel edges with a single equivalent resistance using the parallel formula. Repeat until only the start and end nodes remain connected directly by a single equivalent resistance. Output : The final equivalent resistance value between the designated start and end nodes.","title":"Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function simplify_circuit(G, start, end): while G has more than two nodes: for each node v not in {start, end}: if degree(v) == 2: neighbors = [u, w] if (u,v) and (v,w) not forming a cycle: combine series resistance: R = R(u,v) + R(v,w) remove v, add edge (u,w) with resistance R for each pair of nodes (u, v): if multiple edges between u and v: combine parallel resistances: 1 / R_total = sum(1 / R_i for each edge R_i between u and v) replace edges with single edge of resistance R_total return resistance between start and end Notes: - Cycles must be carefully checked to avoid incorrect series reductions. - Parallel combinations must consider all possible parallel paths.","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: reduced = False # Simplify series connections for node in list(G.nodes): if node in (start, end): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if not nx.has_path(G, u, v) or (node in nx.shortest_path(G, u, v)[1:-1]): r1 = G[u][node]['resistance'] r2 = G[v][node]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) reduced = True break if reduced: continue # Simplify parallel connections for u, v in list(G.edges): parallel_edges = G.get_edge_data(u, v) if isinstance(parallel_edges, dict) and len(parallel_edges) > 1: resistances = [data['resistance'] for key, data in parallel_edges.items()] r_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)]*len(resistances)) G.add_edge(u, v, resistance=r_parallel) reduced = True break if not reduced: break return G[start][end]['resistance']","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#important-implementation-details","text":"The graph must correctly store resistance on edges. Parallel simplification assumes multiple edges between two nodes. This algorithm assumes no complicated sub-circuits like bridges (Wheatstone Bridge) without preprocessing.","title":"Important Implementation Details"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-usage","text":"# Create a graph G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=5) G.add_edge('B', 'D', resistance=6) # Compute equivalent resistance between A and D req = simplify_circuit(G, 'A', 'D') print(f\"Equivalent resistance between A and D: {req} ohms\")","title":"Example Usage"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-examples","text":"","title":"Test Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series-connection","text":"Two resistors in series: \\(2 \\Omega\\) + \\(3 \\Omega\\) = \\(5 \\Omega\\) Total equivalent resistance: \\[ R_{\\text{eq}} = 5 \\Omega \\]","title":"1. Simple Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel-connection","text":"Two resistors in parallel: \\[ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} \\] \\[ \\frac{1}{R} = \\frac{5}{12} \\] Thus, \\[ R = 2.4 \\Omega \\]","title":"2. Simple Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-complex-graph-nested-combination","text":"Multiple series and parallel configurations are detected automatically. No manual intervention is required for nested groups.","title":"3. Complex Graph (Nested Combination)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"Time Complexity : Series reduction: \\(O(V)\\) per iteration. Parallel reduction: \\(O(E^2)\\) if naive checking. Space Complexity : Storing the graph requires \\(O(V + E)\\) space.","title":"Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Graph Compression : Use data structures like Union-Find to manage node merging. Cycle Detection Optimization : Faster cycle checks can reduce redundant searches. Parallel Computation : Apply parallelism to identify multiple reduction sites at once.","title":"Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Using graph theory , complex electrical circuits can be programmatically simplified. This method provides a powerful framework for: - Rapid analysis of large circuits. - Integration into electrical simulation software. - Automated design and optimization of electronic systems. Future work could extend this approach to dynamically changing circuits, non-linear components, and real-time optimization.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcda Problem 1: Exploring the Central Limit Theorem through Simulations \ud83c\udfaf Motivation The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution \\(N(\\mu, \\sigma^2/n)\\) as the sample size \\(n\\) increases, regardless of the shape of the original population distribution. Simulations provide an intuitive, visual, and hands-on way to observe this phenomenon, deepening our understanding of the CLT. \ud83d\udee0 Task Breakdown 1. Simulating Sampling Distributions We will select several types of population distributions : Uniform distribution $ U(a, b) $ Exponential distribution $ \\text{Exp}(\\lambda) $ Binomial distribution $ \\text{Bin}(n, p) $ Normal distribution $ N(\\mu, \\sigma^2) $ (for control) For each distribution: Generate a large dataset (population size $ \\approx 10^5 $). 2. Sampling and Visualization For each population: Randomly sample subsets of various sizes: \\(n \\in \\{5, 10, 30, 50, 100\\}\\) Repeat 1000 times to build the sampling distribution of \\(\\bar{X}\\) . Visualize: Histograms with KDE (Kernel Density Estimation) plots. QQ-plots to check normality visually. 3. Parameter Exploration Investigate: How the sample size \\(n\\) affects convergence speed. How the population shape and population variance \\(\\sigma^2\\) influence the spread and skewness of the sampling distribution. 4. Practical Applications of the CLT The Central Limit Theorem is crucial for: Estimation : Confidence intervals for population means. Quality Control : Monitoring production processes. Finance : Risk assessment and prediction models. Machine Learning : Model evaluation with cross-validation. \ud83d\udcc4 Deliverables Well-structured Markdown report . Python notebooks or scripts implementing the simulations. Plots showcasing the evolution toward normality. Discussion explaining observations and theoretical justifications. \ud83d\udca1 Hints and Resources Use: numpy for random sampling. matplotlib and seaborn for visualization. scipy.stats.probplot for QQ-plots. Start simple, progressively increase complexity. Always calculate and show: Sample mean \\(\\bar{X}\\) Sample variance \\(S^2\\) \ud83e\uddea Python Simulation Import Required Libraries ```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns import scipy.stats as stats sns.set(style=\"whitegrid\")","title":"\ud83d\udcda Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcda Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution \\(N(\\mu, \\sigma^2/n)\\) as the sample size \\(n\\) increases, regardless of the shape of the original population distribution. Simulations provide an intuitive, visual, and hands-on way to observe this phenomenon, deepening our understanding of the CLT.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-breakdown","text":"","title":"\ud83d\udee0 Task Breakdown"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We will select several types of population distributions : Uniform distribution $ U(a, b) $ Exponential distribution $ \\text{Exp}(\\lambda) $ Binomial distribution $ \\text{Bin}(n, p) $ Normal distribution $ N(\\mu, \\sigma^2) $ (for control) For each distribution: Generate a large dataset (population size $ \\approx 10^5 $).","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each population: Randomly sample subsets of various sizes: \\(n \\in \\{5, 10, 30, 50, 100\\}\\) Repeat 1000 times to build the sampling distribution of \\(\\bar{X}\\) . Visualize: Histograms with KDE (Kernel Density Estimation) plots. QQ-plots to check normality visually.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Investigate: How the sample size \\(n\\) affects convergence speed. How the population shape and population variance \\(\\sigma^2\\) influence the spread and skewness of the sampling distribution.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-the-clt","text":"The Central Limit Theorem is crucial for: Estimation : Confidence intervals for population means. Quality Control : Monitoring production processes. Finance : Risk assessment and prediction models. Machine Learning : Model evaluation with cross-validation.","title":"4. Practical Applications of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"Well-structured Markdown report . Python notebooks or scripts implementing the simulations. Plots showcasing the evolution toward normality. Discussion explaining observations and theoretical justifications.","title":"\ud83d\udcc4 Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use: numpy for random sampling. matplotlib and seaborn for visualization. scipy.stats.probplot for QQ-plots. Start simple, progressively increase complexity. Always calculate and show: Sample mean \\(\\bar{X}\\) Sample variance \\(S^2\\)","title":"\ud83d\udca1 Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-simulation","text":"","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#import-required-libraries","text":"```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns import scipy.stats as stats sns.set(style=\"whitegrid\")","title":"Import Required Libraries"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}