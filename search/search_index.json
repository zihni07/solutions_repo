{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: A Detailed Exploration 1. Theoretical Foundation Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion can be analyzed by decomposing it into horizontal and vertical components. This type of motion is governed by kinematic equations and provides fundamental insights into physics and engineering applications. 1.1 Governing Equations The equations of motion follow from Newton's second law: \\[ F = ma \\] For projectile motion in two dimensions: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion due to gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: $ v_0 $ is the initial velocity, $ \\theta $ is the launch angle, $ g $ is the acceleration due to gravity, $ t $ is the time elapsed. The velocity components at any time $ t $ are: \\[ v_x = v_0 \\cos(\\theta) $$ $$ v_y = v_0 \\sin(\\theta) - g t \\] 1.2 Time of Flight The time when the projectile reaches the ground is found by setting $ y = 0 $: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] This equation provides insight into how the initial speed and angle affect the duration of flight. 1.3 Range of the Projectile The horizontal range is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range occurs at $ \\theta = 45^\\circ $ and is directly proportional to the square of the initial velocity. 1.4 Maximum Height The highest point $ y_{max} $ is found when $ v_y = 0 $: \\[ y_{max} = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] This formula helps determine the peak altitude reached by the projectile. 2. Analysis of Range Dependence 2.1 Effect of Launch Angle The range follows a sinusoidal relationship, peaking at $ 45^\\circ $. Complementary angles ($ \\theta $ and $ 90^\\circ - \\theta $) yield the same range. 2.2 Effect of Initial Velocity Range increases quadratically with initial speed. A higher initial velocity results in a longer trajectory and increased maximum height. 2.3 Effect of Gravity Stronger gravity shortens both range and time of flight. On celestial bodies with lower gravity (e.g., the Moon), projectiles travel much farther. 2.4 Effect of Launch Height A projectile launched from an elevated position stays airborne longer, extending its range. The additional term for height in the range equation introduces asymmetry in the trajectory. 3. Practical Applications 3.1 Sports Ballistics in football, basketball, and golf. Optimizing angles for maximum distance or height. 3.2 Engineering and Ballistics Missile trajectory calculations. Design of artillery and projectile-based defense systems. 3.3 Space Science Rocket launches and planetary landings. Escape velocity and orbital mechanics calculations. 4. Implementation in Python Below is a Python script that simulates projectile motion and plots various aspects of the motion: 4.1 Range vs. Launch Angle 4.2 Projectile Trajectory Simulation 4.3 Maximum Height vs. Launch Angle 4.4 Extending the Simulation Modify the code to include different gravitational accelerations. Introduce air resistance for a more realistic trajectory. Simulate varying launch heights. 5. Limitations and Extensions 5.1 Assumptions in the Ideal Model Neglecting Air Resistance: In reality, drag alters the trajectory. Ignoring Wind Effects: Crosswinds and tailwinds significantly impact real-world projectile motion. Constant Gravity: Gravity slightly varies with altitude, especially in high-altitude launches. 5.2 Advanced Considerations Numerical Simulations: Solving differential equations for motion with drag. Uneven Terrain: Adjusting the impact location based on varying elevation. Multi-Stage Projectiles: Studying objects with varying thrust and mass changes (e.g., rockets). This Markdown document serves as a comprehensive introduction to projectile motion, its equations, analysis, and Python simulation. It also provides avenues for further research and computational modeling in real-world applications.","title":"Projectile Motion: A Detailed Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-a-detailed-exploration","text":"","title":"Projectile Motion: A Detailed Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion can be analyzed by decomposing it into horizontal and vertical components. This type of motion is governed by kinematic equations and provides fundamental insights into physics and engineering applications.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations","text":"The equations of motion follow from Newton's second law: \\[ F = ma \\] For projectile motion in two dimensions: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion due to gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: $ v_0 $ is the initial velocity, $ \\theta $ is the launch angle, $ g $ is the acceleration due to gravity, $ t $ is the time elapsed. The velocity components at any time $ t $ are: \\[ v_x = v_0 \\cos(\\theta) $$ $$ v_y = v_0 \\sin(\\theta) - g t \\]","title":"1.1 Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time when the projectile reaches the ground is found by setting $ y = 0 $: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] This equation provides insight into how the initial speed and angle affect the duration of flight.","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-of-the-projectile","text":"The horizontal range is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range occurs at $ \\theta = 45^\\circ $ and is directly proportional to the square of the initial velocity.","title":"1.3 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-maximum-height","text":"The highest point $ y_{max} $ is found when $ v_y = 0 $: \\[ y_{max} = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] This formula helps determine the peak altitude reached by the projectile.","title":"1.4 Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-range-dependence","text":"","title":"2. Analysis of Range Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-effect-of-launch-angle","text":"The range follows a sinusoidal relationship, peaking at $ 45^\\circ $. Complementary angles ($ \\theta $ and $ 90^\\circ - \\theta $) yield the same range.","title":"2.1 Effect of Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-effect-of-initial-velocity","text":"Range increases quadratically with initial speed. A higher initial velocity results in a longer trajectory and increased maximum height.","title":"2.2 Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-effect-of-gravity","text":"Stronger gravity shortens both range and time of flight. On celestial bodies with lower gravity (e.g., the Moon), projectiles travel much farther.","title":"2.3 Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-effect-of-launch-height","text":"A projectile launched from an elevated position stays airborne longer, extending its range. The additional term for height in the range equation introduces asymmetry in the trajectory.","title":"2.4 Effect of Launch Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-sports","text":"Ballistics in football, basketball, and golf. Optimizing angles for maximum distance or height.","title":"3.1 Sports"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-engineering-and-ballistics","text":"Missile trajectory calculations. Design of artillery and projectile-based defense systems.","title":"3.2 Engineering and Ballistics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-space-science","text":"Rocket launches and planetary landings. Escape velocity and orbital mechanics calculations.","title":"3.3 Space Science"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"Below is a Python script that simulates projectile motion and plots various aspects of the motion:","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#41-range-vs-launch-angle","text":"","title":"4.1 Range vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#42-projectile-trajectory-simulation","text":"","title":"4.2 Projectile Trajectory Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#43-maximum-height-vs-launch-angle","text":"","title":"4.3 Maximum Height vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#44-extending-the-simulation","text":"Modify the code to include different gravitational accelerations. Introduce air resistance for a more realistic trajectory. Simulate varying launch heights.","title":"4.4 Extending the Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#51-assumptions-in-the-ideal-model","text":"Neglecting Air Resistance: In reality, drag alters the trajectory. Ignoring Wind Effects: Crosswinds and tailwinds significantly impact real-world projectile motion. Constant Gravity: Gravity slightly varies with altitude, especially in high-altitude launches.","title":"5.1 Assumptions in the Ideal Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#52-advanced-considerations","text":"Numerical Simulations: Solving differential equations for motion with drag. Uneven Terrain: Adjusting the impact location based on varying elevation. Multi-Stage Projectiles: Studying objects with varying thrust and mass changes (e.g., rockets). This Markdown document serves as a comprehensive introduction to projectile motion, its equations, analysis, and Python simulation. It also provides avenues for further research and computational modeling in real-world applications.","title":"5.2 Advanced Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum: A Comprehensive Study 1. Theoretical Foundation The forced damped pendulum is a nonlinear dynamical system governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum. 1.1 Approximate Solutions for Small Angles For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator with well-known resonance conditions: \\[ \\omega \\approx \\omega_0 \\] At resonance, oscillation amplitude can increase significantly if damping is low. 1.2 Energy Analysis The total energy of the pendulum system is given by: \\[ E = \\frac{1}{2} m L^2 \\left( \\dot{\\theta}^2 \\right) + mgL(1 - \\cos\\theta) \\] Energy dissipation occurs due to damping, while the driving force periodically injects energy. 2. Analysis of Dynamics The system's behavior varies based on damping, forcing, and initial conditions: Low damping, weak forcing: Regular oscillations similar to simple harmonic motion. Moderate forcing and damping: Quasi-periodic and periodic oscillations. High forcing and low damping: Transition to chaotic motion. 2.1 Phase Space Analysis The pendulum's state in phase space ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) reveals: - Periodic motion: Closed loops. - Chaotic motion: Complex, fractal-like structures. 2.2 Poincar\u00e9 Sections By sampling phase space at discrete intervals, Poincar\u00e9 sections illustrate order-to-chaos transitions. 2.3 Bifurcation and Chaos By varying \\(A\\) , the system undergoes period-doubling cascades, leading to chaotic regimes. 3. Practical Applications Engineering: Suspension bridges, vibration control. Energy Harvesting: Mechanical-to-electrical conversion. Biomechanics: Gait dynamics, neural rhythms. Electrical Circuits: Analogous behavior in driven RLC circuits. 4. Implementation in Python 4.1 Simulating the Forced Damped Pendulum 4.2 Phase Space Plot 4.3 Poincar\u00e9 Section 4.4 Bifurcation Diagram 5. Limitations and Future Research 5.1 Model Limitations Neglecting complex damping : Real-world damping is nonlinear. Non-periodic forcing : More general forcing functions introduce richer dynamics. Multi-body interactions : Coupled pendulums exhibit additional complexity. 5.2 Future Research Directions Lyapunov exponent analysis for chaos detection. Stochastic forcing : Effects of noise and random perturbations. Higher-order bifurcation studies in advanced dynamical systems. Conclusion This extended analysis of the forced damped pendulum provides theoretical insights, computational tools, and real-world applications. Using Python simulations, we explore resonance, chaos, and bifurcations, demonstrating the pendulum\u2019s role as a fundamental nonlinear system in physics and engineering.","title":"Forced Damped Pendulum: A Comprehensive Study"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-a-comprehensive-study","text":"","title":"Forced Damped Pendulum: A Comprehensive Study"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear dynamical system governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-approximate-solutions-for-small-angles","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator with well-known resonance conditions: \\[ \\omega \\approx \\omega_0 \\] At resonance, oscillation amplitude can increase significantly if damping is low.","title":"1.1 Approximate Solutions for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-energy-analysis","text":"The total energy of the pendulum system is given by: \\[ E = \\frac{1}{2} m L^2 \\left( \\dot{\\theta}^2 \\right) + mgL(1 - \\cos\\theta) \\] Energy dissipation occurs due to damping, while the driving force periodically injects energy.","title":"1.2 Energy Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The system's behavior varies based on damping, forcing, and initial conditions: Low damping, weak forcing: Regular oscillations similar to simple harmonic motion. Moderate forcing and damping: Quasi-periodic and periodic oscillations. High forcing and low damping: Transition to chaotic motion.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-phase-space-analysis","text":"The pendulum's state in phase space ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) reveals: - Periodic motion: Closed loops. - Chaotic motion: Complex, fractal-like structures.","title":"2.1 Phase Space Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-poincare-sections","text":"By sampling phase space at discrete intervals, Poincar\u00e9 sections illustrate order-to-chaos transitions.","title":"2.2 Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-bifurcation-and-chaos","text":"By varying \\(A\\) , the system undergoes period-doubling cascades, leading to chaotic regimes.","title":"2.3 Bifurcation and Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Engineering: Suspension bridges, vibration control. Energy Harvesting: Mechanical-to-electrical conversion. Biomechanics: Gait dynamics, neural rhythms. Electrical Circuits: Analogous behavior in driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-in-python","text":"","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-simulating-the-forced-damped-pendulum","text":"","title":"4.1 Simulating the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-phase-space-plot","text":"","title":"4.2 Phase Space Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-poincare-section","text":"","title":"4.3 Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#44-bifurcation-diagram","text":"","title":"4.4 Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-future-research","text":"","title":"5. Limitations and Future Research"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-model-limitations","text":"Neglecting complex damping : Real-world damping is nonlinear. Non-periodic forcing : More general forcing functions introduce richer dynamics. Multi-body interactions : Coupled pendulums exhibit additional complexity.","title":"5.1 Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-future-research-directions","text":"Lyapunov exponent analysis for chaos detection. Stochastic forcing : Effects of noise and random perturbations. Higher-order bifurcation studies in advanced dynamical systems.","title":"5.2 Future Research Directions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This extended analysis of the forced damped pendulum provides theoretical insights, computational tools, and real-world applications. Using Python simulations, we explore resonance, chaos, and bifurcations, demonstrating the pendulum\u2019s role as a fundamental nonlinear system in physics and engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of its semi-major axis (orbital radius in circular orbits). This relationship is fundamental in celestial mechanics, helping astronomers determine planetary motions and gravitational interactions. Understanding this law allows us to predict satellite orbits, planetary system behavior, and even exoplanetary systems. Kepler\u2019s Third Law Derivation For a circular orbit, the centripetal force required to maintain motion is provided by gravitational attraction: \\[ F_c = \\frac{m v^2}{r} \\] \\[ F_g = \\frac{G M m}{r^2} \\] Equating these forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Since velocity \\(v\\) is given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\(v\\) in the equation: \\[ \\frac{m (4 \\pi^2 r^2)}{T^2 r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) and rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This confirms Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] where \\(G\\) is the gravitational constant, \\(M\\) is the central body\u2019s mass, \\(T\\) is the orbital period, and \\(r\\) is the orbital radius. Implications in Astronomy Used to calculate planetary masses and distances. Helps determine exoplanet properties. Crucial for spacecraft mission planning and satellite deployment. Real-World Examples Moon's Orbit Around Earth Given Earth\u2019s mass ( \\(5.972 \\times 10^{24}\\) kg) and the Moon\u2019s average orbital radius ( \\(3.84 \\times 10^8\\) m), Kepler\u2019s Law predicts the Moon\u2019s orbital period correctly (~27.3 days). Planets in the Solar System The relationship holds true for all planets orbiting the Sun, reinforcing its universal applicability. Computational Model in Python The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law graphically. ![ ]![alt ! Extension to Elliptical Orbits Kepler\u2019s Third Law extends to elliptical orbits, where the semi-major axis replaces the orbital radius: \\[ T^2 \\propto a^3 \\] This generalization helps describe non-circular planetary orbits and spacecraft trajectories. Conclusion Kepler\u2019s Third Law remains a powerful tool in celestial mechanics, aiding in planetary studies, exoplanet discovery, and space mission design. Its mathematical elegance bridges theoretical physics and real-world applications.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of a planet's orbital period is proportional to the cube of its semi-major axis (orbital radius in circular orbits). This relationship is fundamental in celestial mechanics, helping astronomers determine planetary motions and gravitational interactions. Understanding this law allows us to predict satellite orbits, planetary system behavior, and even exoplanetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-derivation","text":"For a circular orbit, the centripetal force required to maintain motion is provided by gravitational attraction: \\[ F_c = \\frac{m v^2}{r} \\] \\[ F_g = \\frac{G M m}{r^2} \\] Equating these forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Since velocity \\(v\\) is given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\(v\\) in the equation: \\[ \\frac{m (4 \\pi^2 r^2)}{T^2 r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) and rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This confirms Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] where \\(G\\) is the gravitational constant, \\(M\\) is the central body\u2019s mass, \\(T\\) is the orbital period, and \\(r\\) is the orbital radius.","title":"Kepler\u2019s Third Law Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Used to calculate planetary masses and distances. Helps determine exoplanet properties. Crucial for spacecraft mission planning and satellite deployment.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth Given Earth\u2019s mass ( \\(5.972 \\times 10^{24}\\) kg) and the Moon\u2019s average orbital radius ( \\(3.84 \\times 10^8\\) m), Kepler\u2019s Law predicts the Moon\u2019s orbital period correctly (~27.3 days). Planets in the Solar System The relationship holds true for all planets orbiting the Sun, reinforcing its universal applicability.","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model-in-python","text":"The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law graphically. ![ ]![alt !","title":"Computational Model in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law extends to elliptical orbits, where the semi-major axis replaces the orbital radius: \\[ T^2 \\propto a^3 \\] This generalization helps describe non-circular planetary orbits and spacecraft trajectories.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law remains a powerful tool in celestial mechanics, aiding in planetary studies, exoplanet discovery, and space mission design. Its mathematical elegance bridges theoretical physics and real-world applications.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Cosmic Velocities Definitions First Cosmic Velocity (Orbital Velocity): The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius. This velocity ensures that the centrifugal force due to orbital motion balances the gravitational pull. Second Cosmic Velocity (Escape Velocity): The minimum velocity required to escape a celestial body's gravitational pull without further propulsion. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. At this velocity, the kinetic energy equals the gravitational potential energy, allowing the object to escape indefinitely. Third Cosmic Velocity (Solar System Escape Velocity: The velocity required to escape the gravitational influence of the entire solar system. It depends on the escape velocity from Earth and the Sun\u2019s influence: $$ v_3 = \\sqrt{v_2^2 + v_{esc,\\odot}^2} $$ Where \\(v_{esc,\\odot}\\) is the escape velocity from the Sun. This is crucial for interstellar missions and deep space exploration. Mathematical Derivation To derive the escape velocity, consider the conservation of energy: \\[ \\text{Total Energy} = \\text{Kinetic Energy} + \\text{Gravitational Potential Energy} \\] \\[ \\frac{1}{2} m v^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] This equation applies to any celestial body, with variations in mass and radius affecting the velocity required for escape. Computational Analysis The following Python script calculates and visualizes these velocities for Earth, Mars, and Jupiter. Importance in Space Exploration Satellites & Space Stations: The first cosmic velocity is crucial for placing satellites in stable orbits. The International Space Station (ISS) orbits Earth at approximately 7.66 km/s. Lunar & Interplanetary Missions: The second cosmic velocity is essential for missions to the Moon, Mars, and beyond. Apollo missions had to exceed Earth's escape velocity to reach the Moon. Interstellar Travel: The third cosmic velocity is relevant for long-term space exploration. Probes like Voyager 1 and 2 have achieved solar system escape velocity and are currently traveling into interstellar space. Conclusion Escape and cosmic velocities define fundamental thresholds in celestial mechanics, guiding modern space exploration efforts. Understanding these principles allows for more efficient mission planning and technological advancements in space travel. They provide the foundation for future endeavors, including planetary colonization and interstellar exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-definitions","text":"First Cosmic Velocity (Orbital Velocity): The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius. This velocity ensures that the centrifugal force due to orbital motion balances the gravitational pull. Second Cosmic Velocity (Escape Velocity): The minimum velocity required to escape a celestial body's gravitational pull without further propulsion. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. At this velocity, the kinetic energy equals the gravitational potential energy, allowing the object to escape indefinitely. Third Cosmic Velocity (Solar System Escape Velocity: The velocity required to escape the gravitational influence of the entire solar system. It depends on the escape velocity from Earth and the Sun\u2019s influence: $$ v_3 = \\sqrt{v_2^2 + v_{esc,\\odot}^2} $$ Where \\(v_{esc,\\odot}\\) is the escape velocity from the Sun. This is crucial for interstellar missions and deep space exploration.","title":"Cosmic Velocities Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation","text":"To derive the escape velocity, consider the conservation of energy: \\[ \\text{Total Energy} = \\text{Kinetic Energy} + \\text{Gravitational Potential Energy} \\] \\[ \\frac{1}{2} m v^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] This equation applies to any celestial body, with variations in mass and radius affecting the velocity required for escape.","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-analysis","text":"The following Python script calculates and visualizes these velocities for Earth, Mars, and Jupiter.","title":"Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Satellites & Space Stations: The first cosmic velocity is crucial for placing satellites in stable orbits. The International Space Station (ISS) orbits Earth at approximately 7.66 km/s. Lunar & Interplanetary Missions: The second cosmic velocity is essential for missions to the Moon, Mars, and beyond. Apollo missions had to exceed Earth's escape velocity to reach the Moon. Interstellar Travel: The third cosmic velocity is relevant for long-term space exploration. Probes like Voyager 1 and 2 have achieved solar system escape velocity and are currently traveling into interstellar space.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape and cosmic velocities define fundamental thresholds in celestial mechanics, guiding modern space exploration efforts. Understanding these principles allows for more efficient mission planning and technological advancements in space travel. They provide the foundation for future endeavors, including planetary colonization and interstellar exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving spacecraft near Earth, its trajectory is influenced by its initial velocity and the gravitational pull of Earth. Understanding these trajectories is crucial for various space missions, including satellite deployment, reentry planning, and interplanetary travel. This study aims to analyze possible trajectories, simulate them numerically, and visualize the results. Governing Equations The motion of the payload is governed by Newton's Law of Gravitation and Newton's Second Law of Motion: \\[ F = \\frac{G M_{earth} m}{r^2} \\] where: \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2), \\(M_{earth}\\) is Earth's mass ( \\(5.972 \\times 10^{24}\\) kg), \\(r\\) is the radial distance from Earth's center, \\(m\\) is the mass of the payload. Using Newton\u2019s Second Law ( \\(F = ma\\) ), we derive the equations of motion in two-dimensional Cartesian coordinates: \\[ a_x = -\\frac{G M_{earth} x}{r^3}, \\quad a_y = -\\frac{G M_{earth} y}{r^3} \\] where \\((x, y)\\) represents the position of the payload. Types of Possible Trajectories Circular Orbit : If the velocity of the payload is precisely the orbital velocity for its altitude, it will move in a circular orbit around Earth. Elliptical Orbit : When the velocity is below escape velocity but not equal to circular velocity, the payload follows an elliptical orbit. Parabolic Trajectory : If the payload\u2019s velocity is exactly equal to escape velocity ( \\(v_{esc} = \\sqrt{2 G M_{earth} / r}\\) ), it will follow a parabolic trajectory, escaping Earth's gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence completely. Suborbital Trajectory : If the velocity is too low, the payload will follow a ballistic trajectory and reenter Earth's atmosphere. Numerical Simulation We employ the Runge-Kutta method to integrate these equations and determine the payload's trajectory. Python Implementation Additional Simulations Effect of Atmospheric Drag Conclusion By simulating the motion of a payload released near Earth, we gain insights into orbital mechanics and space mission design. This study provides a computational approach to predicting different possible trajectories based on initial conditions. Further analysis can incorporate atmospheric drag, gravitational perturbations, and interactions with other celestial bodies. ```","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving spacecraft near Earth, its trajectory is influenced by its initial velocity and the gravitational pull of Earth. Understanding these trajectories is crucial for various space missions, including satellite deployment, reentry planning, and interplanetary travel. This study aims to analyze possible trajectories, simulate them numerically, and visualize the results.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The motion of the payload is governed by Newton's Law of Gravitation and Newton's Second Law of Motion: \\[ F = \\frac{G M_{earth} m}{r^2} \\] where: \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2), \\(M_{earth}\\) is Earth's mass ( \\(5.972 \\times 10^{24}\\) kg), \\(r\\) is the radial distance from Earth's center, \\(m\\) is the mass of the payload. Using Newton\u2019s Second Law ( \\(F = ma\\) ), we derive the equations of motion in two-dimensional Cartesian coordinates: \\[ a_x = -\\frac{G M_{earth} x}{r^3}, \\quad a_y = -\\frac{G M_{earth} y}{r^3} \\] where \\((x, y)\\) represents the position of the payload.","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"Circular Orbit : If the velocity of the payload is precisely the orbital velocity for its altitude, it will move in a circular orbit around Earth. Elliptical Orbit : When the velocity is below escape velocity but not equal to circular velocity, the payload follows an elliptical orbit. Parabolic Trajectory : If the payload\u2019s velocity is exactly equal to escape velocity ( \\(v_{esc} = \\sqrt{2 G M_{earth} / r}\\) ), it will follow a parabolic trajectory, escaping Earth's gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence completely. Suborbital Trajectory : If the velocity is too low, the payload will follow a ballistic trajectory and reenter Earth's atmosphere.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"We employ the Runge-Kutta method to integrate these equations and determine the payload's trajectory.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#additional-simulations","text":"","title":"Additional Simulations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#effect-of-atmospheric-drag","text":"","title":"Effect of Atmospheric Drag"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By simulating the motion of a payload released near Earth, we gain insights into orbital mechanics and space mission design. This study provides a computational approach to predicting different possible trajectories based on initial conditions. Further analysis can incorporate atmospheric drag, gravitational perturbations, and interactions with other celestial bodies. ```","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Simulation Introduction Interference occurs when waves from different sources overlap, forming unique patterns. On a water surface, this can be seen when ripples from different points meet, creating interference patterns. Understanding these patterns helps in visualizing wave behavior and the principles of constructive and destructive interference. Problem Statement We aim to analyze interference patterns formed due to the superposition of waves emitted from point sources arranged at the vertices of a chosen regular polygon. This will provide insights into wave interactions and phase relationships. Mathematical Model A circular wave from a point source at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos (kr - \\omega t + \\phi) \\] where: - \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, - \\(\\phi\\) is the initial phase. For multiple wave sources, the total displacement at any point is given by the superposition principle: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\(N\\) is the number of sources. Implementation in Python We use Python with Matplotlib and NumPy to simulate wave interference patterns. The approach includes: 1. Choosing a regular polygon (triangle, square, pentagon, etc.). 2. Placing wave sources at its vertices. 3. Calculating the resultant wave field by summing individual waves. 4. Visualizing the interference pattern. Results and Observations Different polygons produce distinct interference patterns. Regions of constructive interference (bright spots) and destructive interference (dark spots) are clearly visible. Increasing the number of sources leads to more complex patterns. A 3D visualization gives a more intuitive understanding of amplitude variations. Conclusion This simulation helps in understanding wave superposition in a visually intuitive way. The principle extends to many physical phenomena, including optics, acoustics, and quantum mechanics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-simulation","text":"","title":"Wave Interference Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"Interference occurs when waves from different sources overlap, forming unique patterns. On a water surface, this can be seen when ripples from different points meet, creating interference patterns. Understanding these patterns helps in visualizing wave behavior and the principles of constructive and destructive interference.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We aim to analyze interference patterns formed due to the superposition of waves emitted from point sources arranged at the vertices of a chosen regular polygon. This will provide insights into wave interactions and phase relationships.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"A circular wave from a point source at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos (kr - \\omega t + \\phi) \\] where: - \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source, - \\(\\phi\\) is the initial phase. For multiple wave sources, the total displacement at any point is given by the superposition principle: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\(N\\) is the number of sources.","title":"Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#implementation-in-python","text":"We use Python with Matplotlib and NumPy to simulate wave interference patterns. The approach includes: 1. Choosing a regular polygon (triangle, square, pentagon, etc.). 2. Placing wave sources at its vertices. 3. Calculating the resultant wave field by summing individual waves. 4. Visualizing the interference pattern.","title":"Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-and-observations","text":"Different polygons produce distinct interference patterns. Regions of constructive interference (bright spots) and destructive interference (dark spots) are clearly visible. Increasing the number of sources leads to more complex patterns. A 3D visualization gives a more intuitive understanding of amplitude variations.","title":"Results and Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation helps in understanding wave superposition in a visually intuitive way. The principle extends to many physical phenomena, including optics, acoustics, and quantum mechanics.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism \u2014 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as: \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories arising from this force, gaining both qualitative and quantitative insights into real-world systems. Task 1. Exploration of Applications Identify systems where the Lorentz force plays a key role: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., Tokamaks) Earth's magnetosphere interactions with solar wind Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling particle motion, such as: Velocity selection in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields (velocity selector) Magnetic bottle traps for confining plasmas 2. Simulating Particle Motion Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. A uniform electric field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate various particle motions: Circular motion Helical motion Linear acceleration Drift motion in crossed fields 3. Parameter Exploration Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge ( \\(q\\) ) and mass ( \\(m\\) ) of the particle Observe how these parameters influence: Larmor radius Cyclotron frequency Drift velocity 4. Visualization Create labeled 2D and 3D plots: X vs Y, X vs Z, and 3D trajectories Highlight key physical phenomena: Larmor radius Cyclotron frequency \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity Solution Equations of Motion The Lorentz force provides the basis for the equations of motion: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] Numerical Integration We will use Euler's method for simplicity, but Runge-Kutta 4th order (RK4) is preferable for higher accuracy. Python Code (Euler Method) Additional: Runge-Kutta Method Observations Theoretical Background Cyclotron Frequency \\(\\omega_c\\) : $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius \\(r_L\\) : $$ r_L = \\frac{mv_\\perp}{qB} $$ Where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) . Simulation Insights Pure magnetic fields: Particles move in perfect circles (or helices if there is a \\(v_z\\) component). Crossed fields: Particles drift at velocity \\(\\mathbf{v}_d\\) : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Particle mass and charge directly affect the radius and frequency of rotation. Deliverables Summary A Python notebook implementing both Euler and Runge-Kutta methods. Simulations for: Uniform \\(\\mathbf{B}\\) fields Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields Clear and well-labeled plots. Discussion of practical relevance to cyclotrons, plasma traps, and space physics. Hints and Resources For better precision, use adaptive time-stepping methods. Explore relativistic effects for ultra-fast particles using the Lorentz factor \\(\\gamma\\) . Extend simulations to non-uniform fields or magnetic mirrors. Key References: - Griffiths, D.J., Introduction to Electrodynamics - Birdsall and Langdon, Plasma Physics via Computer Simulation Conclusion By applying the Lorentz force in numerical simulations, we develop an intuitive and quantitative understanding of charged particle motion in electromagnetic fields. These principles underpin technologies from particle accelerators to magnetic plasma confinement systems, forming a bridge between theoretical electromagnetism and cutting-edge applications.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-simulating-the-effects-of-the-lorentz-force","text":"","title":"Electromagnetism \u2014 Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories arising from this force, gaining both qualitative and quantitative insights into real-world systems.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Identify systems where the Lorentz force plays a key role: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., Tokamaks) Earth's magnetosphere interactions with solar wind Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling particle motion, such as: Velocity selection in crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields (velocity selector) Magnetic bottle traps for confining plasmas","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. A uniform electric field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate various particle motions: Circular motion Helical motion Linear acceleration Drift motion in crossed fields","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge ( \\(q\\) ) and mass ( \\(m\\) ) of the particle Observe how these parameters influence: Larmor radius Cyclotron frequency Drift velocity","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Create labeled 2D and 3D plots: X vs Y, X vs Z, and 3D trajectories Highlight key physical phenomena: Larmor radius Cyclotron frequency \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#solution","text":"","title":"Solution"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"The Lorentz force provides the basis for the equations of motion: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\]","title":"Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-integration","text":"We will use Euler's method for simplicity, but Runge-Kutta 4th order (RK4) is preferable for higher accuracy.","title":"Numerical Integration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-euler-method","text":"","title":"Python Code (Euler Method)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#additional-runge-kutta-method","text":"","title":"Additional: Runge-Kutta Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations","text":"","title":"Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theoretical-background","text":"Cyclotron Frequency \\(\\omega_c\\) : $$ \\omega_c = \\frac{qB}{m} $$ Larmor Radius \\(r_L\\) : $$ r_L = \\frac{mv_\\perp}{qB} $$ Where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) .","title":"Theoretical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-insights","text":"Pure magnetic fields: Particles move in perfect circles (or helices if there is a \\(v_z\\) component). Crossed fields: Particles drift at velocity \\(\\mathbf{v}_d\\) : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Particle mass and charge directly affect the radius and frequency of rotation.","title":"Simulation Insights"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables-summary","text":"A Python notebook implementing both Euler and Runge-Kutta methods. Simulations for: Uniform \\(\\mathbf{B}\\) fields Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields Clear and well-labeled plots. Discussion of practical relevance to cyclotrons, plasma traps, and space physics.","title":"Deliverables Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"For better precision, use adaptive time-stepping methods. Explore relativistic effects for ultra-fast particles using the Lorentz factor \\(\\gamma\\) . Extend simulations to non-uniform fields or magnetic mirrors. Key References: - Griffiths, D.J., Introduction to Electrodynamics - Birdsall and Langdon, Plasma Physics via Computer Simulation","title":"Hints and Resources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"By applying the Lorentz force in numerical simulations, we develop an intuitive and quantitative understanding of charged particle motion in electromagnetic fields. These principles underpin technologies from particle accelerators to magnetic plasma confinement systems, forming a bridge between theoretical electromagnetism and cutting-edge applications.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Calculation Using Graph Theory Introduction Calculating equivalent resistance in complex circuits can be tedious using traditional methods. Graph theory provides a structured and powerful approach: Nodes represent junctions where multiple components connect. Edges represent resistors, with weights equal to resistance values. By representing circuits as graphs, we gain access to efficient algorithms that simplify complex networks systematically. Iterative application of series and parallel reductions allows us to simplify any network into a single resistance value, regardless of its complexity. Applications of this method span: - Electrical circuit simulation software - Optimization in microchip design - Educational tools for teaching electrical engineering - Automated design verification Key Formulas Series combination : \\[ R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n \\] Series resistors add directly because current must pass through each sequentially. Parallel combination : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Parallel resistors share current across multiple paths, leading to a reduced overall resistance. Algorithm Overview The algorithm proceeds with the following steps: Input : A weighted undirected graph \\(G\\) where: Nodes = circuit junctions Edges = resistors, with weight = resistance in ohms Identify reduction opportunities : Series reduction : Look for nodes with degree 2 that are not the start or end node. Parallel reduction : Look for multiple edges between the same two nodes. Apply simplifications : Series rule : Replace a two-edge chain with a single edge whose resistance is the sum of the two. Parallel rule : Replace multiple parallel edges with a single equivalent resistance using the parallel formula. Repeat until only the start and end nodes remain connected directly by a single equivalent resistance. Output : The final equivalent resistance value between the designated start and end nodes. Pseudocode function simplify_circuit(G, start, end): while G has more than two nodes: for each node v not in {start, end}: if degree(v) == 2: neighbors = [u, w] if (u,v) and (v,w) not forming a cycle: combine series resistance: R = R(u,v) + R(v,w) remove v, add edge (u,w) with resistance R for each pair of nodes (u, v): if multiple edges between u and v: combine parallel resistances: 1 / R_total = sum(1 / R_i for each edge R_i between u and v) replace edges with single edge of resistance R_total return resistance between start and end Notes: - Cycles must be carefully checked to avoid incorrect series reductions. - Parallel combinations must consider all possible parallel paths. Python Implementation import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: reduced = False # Simplify series connections for node in list(G.nodes): if node in (start, end): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if not nx.has_path(G, u, v) or (node in nx.shortest_path(G, u, v)[1:-1]): r1 = G[u][node]['resistance'] r2 = G[v][node]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) reduced = True break if reduced: continue # Simplify parallel connections for u, v in list(G.edges): parallel_edges = G.get_edge_data(u, v) if isinstance(parallel_edges, dict) and len(parallel_edges) > 1: resistances = [data['resistance'] for key, data in parallel_edges.items()] r_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)]*len(resistances)) G.add_edge(u, v, resistance=r_parallel) reduced = True break if not reduced: break return G[start][end]['resistance'] Important Implementation Details The graph must correctly store resistance on edges. Parallel simplification assumes multiple edges between two nodes. This algorithm assumes no complicated sub-circuits like bridges (Wheatstone Bridge) without preprocessing. Example Usage # Create a graph G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=5) G.add_edge('B', 'D', resistance=6) # Compute equivalent resistance between A and D req = simplify_circuit(G, 'A', 'D') print(f\"Equivalent resistance between A and D: {req} ohms\") Test Examples 1. Simple Series Connection Two resistors in series: \\(2 \\Omega\\) + \\(3 \\Omega\\) = \\(5 \\Omega\\) Total equivalent resistance: \\[ R_{\\text{eq}} = 5 \\Omega \\] 2. Simple Parallel Connection Two resistors in parallel: \\[ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} \\] \\[ \\frac{1}{R} = \\frac{5}{12} \\] Thus, \\[ R = 2.4 \\Omega \\] 3. Complex Graph (Nested Combination) Multiple series and parallel configurations are detected automatically. No manual intervention is required for nested groups. Efficiency Analysis Time Complexity : Series reduction: \\(O(V)\\) per iteration. Parallel reduction: \\(O(E^2)\\) if naive checking. Space Complexity : Storing the graph requires \\(O(V + E)\\) space. Potential Improvements Graph Compression : Use data structures like Union-Find to manage node merging. Cycle Detection Optimization : Faster cycle checks can reduce redundant searches. Parallel Computation : Apply parallelism to identify multiple reduction sites at once. Conclusion Using graph theory , complex electrical circuits can be programmatically simplified. This method provides a powerful framework for: - Rapid analysis of large circuits. - Integration into electrical simulation software. - Automated design and optimization of electronic systems. Future work could extend this approach to dynamically changing circuits, non-linear components, and real-time optimization.","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-calculation-using-graph-theory","text":"","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating equivalent resistance in complex circuits can be tedious using traditional methods. Graph theory provides a structured and powerful approach: Nodes represent junctions where multiple components connect. Edges represent resistors, with weights equal to resistance values. By representing circuits as graphs, we gain access to efficient algorithms that simplify complex networks systematically. Iterative application of series and parallel reductions allows us to simplify any network into a single resistance value, regardless of its complexity. Applications of this method span: - Electrical circuit simulation software - Optimization in microchip design - Educational tools for teaching electrical engineering - Automated design verification","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-formulas","text":"Series combination : \\[ R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n \\] Series resistors add directly because current must pass through each sequentially. Parallel combination : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Parallel resistors share current across multiple paths, leading to a reduced overall resistance.","title":"Key Formulas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"The algorithm proceeds with the following steps: Input : A weighted undirected graph \\(G\\) where: Nodes = circuit junctions Edges = resistors, with weight = resistance in ohms Identify reduction opportunities : Series reduction : Look for nodes with degree 2 that are not the start or end node. Parallel reduction : Look for multiple edges between the same two nodes. Apply simplifications : Series rule : Replace a two-edge chain with a single edge whose resistance is the sum of the two. Parallel rule : Replace multiple parallel edges with a single equivalent resistance using the parallel formula. Repeat until only the start and end nodes remain connected directly by a single equivalent resistance. Output : The final equivalent resistance value between the designated start and end nodes.","title":"Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function simplify_circuit(G, start, end): while G has more than two nodes: for each node v not in {start, end}: if degree(v) == 2: neighbors = [u, w] if (u,v) and (v,w) not forming a cycle: combine series resistance: R = R(u,v) + R(v,w) remove v, add edge (u,w) with resistance R for each pair of nodes (u, v): if multiple edges between u and v: combine parallel resistances: 1 / R_total = sum(1 / R_i for each edge R_i between u and v) replace edges with single edge of resistance R_total return resistance between start and end Notes: - Cycles must be carefully checked to avoid incorrect series reductions. - Parallel combinations must consider all possible parallel paths.","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: reduced = False # Simplify series connections for node in list(G.nodes): if node in (start, end): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if not nx.has_path(G, u, v) or (node in nx.shortest_path(G, u, v)[1:-1]): r1 = G[u][node]['resistance'] r2 = G[v][node]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) reduced = True break if reduced: continue # Simplify parallel connections for u, v in list(G.edges): parallel_edges = G.get_edge_data(u, v) if isinstance(parallel_edges, dict) and len(parallel_edges) > 1: resistances = [data['resistance'] for key, data in parallel_edges.items()] r_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)]*len(resistances)) G.add_edge(u, v, resistance=r_parallel) reduced = True break if not reduced: break return G[start][end]['resistance']","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#important-implementation-details","text":"The graph must correctly store resistance on edges. Parallel simplification assumes multiple edges between two nodes. This algorithm assumes no complicated sub-circuits like bridges (Wheatstone Bridge) without preprocessing.","title":"Important Implementation Details"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-usage","text":"# Create a graph G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=5) G.add_edge('B', 'D', resistance=6) # Compute equivalent resistance between A and D req = simplify_circuit(G, 'A', 'D') print(f\"Equivalent resistance between A and D: {req} ohms\")","title":"Example Usage"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-examples","text":"","title":"Test Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series-connection","text":"Two resistors in series: \\(2 \\Omega\\) + \\(3 \\Omega\\) = \\(5 \\Omega\\) Total equivalent resistance: \\[ R_{\\text{eq}} = 5 \\Omega \\]","title":"1. Simple Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel-connection","text":"Two resistors in parallel: \\[ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} \\] \\[ \\frac{1}{R} = \\frac{5}{12} \\] Thus, \\[ R = 2.4 \\Omega \\]","title":"2. Simple Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-complex-graph-nested-combination","text":"Multiple series and parallel configurations are detected automatically. No manual intervention is required for nested groups.","title":"3. Complex Graph (Nested Combination)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"Time Complexity : Series reduction: \\(O(V)\\) per iteration. Parallel reduction: \\(O(E^2)\\) if naive checking. Space Complexity : Storing the graph requires \\(O(V + E)\\) space.","title":"Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Graph Compression : Use data structures like Union-Find to manage node merging. Cycle Detection Optimization : Faster cycle checks can reduce redundant searches. Parallel Computation : Apply parallelism to identify multiple reduction sites at once.","title":"Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Using graph theory , complex electrical circuits can be programmatically simplified. This method provides a powerful framework for: - Rapid analysis of large circuits. - Integration into electrical simulation software. - Automated design and optimization of electronic systems. Future work could extend this approach to dynamically changing circuits, non-linear components, and real-time optimization.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1: Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states: As the sample size increases, the sampling distribution of the sample mean approaches a normal distribution, regardless of the shape of the original population distribution (provided the population has finite mean and variance). Mathematically: If \\(X_1, X_2, ..., X_n\\) are independent and identically distributed random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then as \\(n \\to \\infty\\) , \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] where: - \\(\\bar{X}_n\\) = sample mean, - \\(\\xrightarrow{d}\\) denotes convergence in distribution, - \\(\\mathcal{N}(0, 1)\\) is the standard normal distribution. The CLT justifies the wide use of normal distribution approximations in inferential statistics. By simulating different sampling processes, we can visually and numerically observe this convergence! Task Outline 1. Simulating Sampling Distributions Select three different population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each distribution: Generate a large \"population\" dataset of size \\(100,000\\) or more. Perform sampling of various sizes. 2. Sampling and Visualization For each population: Draw random samples of size \\(n = 5, 10, 30, 50, 100\\) . Repeat the sampling 1000 times to build distributions of sample means. Plot histograms of the sample means. Overlay a normal curve for visual comparison. Observe convergence to normality. 3. Parameter Exploration Explore: Different population variances. How initial distribution shape affects convergence speed. Effect of sample size on variance of the sample mean. 4. Practical Applications Discuss: Estimation of parameters (means, proportions) from samples. Applications in manufacturing, finance, medicine, and machine learning. Deliverables A Markdown document and Python code that: Implements all simulations. Generates plots showing convergence. Includes comparison with true normal distribution. Visualizations of sampling distributions for each sample size. Discussion on: Connection to CLT. Impact of sample size and population variance. Hints and Resources Use: NumPy for random number generation. Matplotlib and Seaborn for beautiful plots. SciPy for overlaying theoretical normal curves. Start simple (Uniform) before moving to complex distributions (Exponential, heavy-tailed). Ensure clear interpretation of sample means and histograms. Full Python Code Define Sampling Function # Define parameters sample_sizes = [5, 10, 30, 50, 100] n_samples = 1000 # Number of repetitions # Helper function to perform sampling and plot results def simulate_sampling(population, pop_name): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(24, 5)) fig.suptitle(f'Sampling Distribution of Sample Means ({pop_name})', fontsize=18) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(n_samples): sample = np.random.choice(population, size=n, replace=True) sample_means.append(np.mean(sample)) # Plot histogram sns.histplot(sample_means, kde=False, ax=axes[i], stat=\"density\", color='skyblue', bins=30) # Fit and plot a normal curve mu, std = np.mean(sample_means), np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) axes[i].plot(x, norm.pdf(x, mu, std), 'r-', lw=2) axes[i].set_title(f'n = {n}') axes[i].set_xlabel('Sample Mean') axes[i].set_ylabel('Density') plt.tight_layout() plt.show() Generate Populations # Create large synthetic populations uniform_pop = np.random.uniform(0, 1, 100000) exponential_pop = np.random.exponential(scale=1, size=100000) binomial_pop = np.random.binomial(n=10, p=0.5, size=100000) Run Simulations simulate_sampling(uniform_pop, \"Uniform Distribution\") simulate_sampling(exponential_pop, \"Exponential Distribution\") simulate_sampling(binomial_pop, \"Binomial Distribution\") Additional Exploration: Heavy-Tailed Population # Pareto (heavy-tailed) distribution pareto_pop = (np.random.pareto(a=2, size=100000) + 1) * 2 simulate_sampling(pareto_pop, \"Pareto (Heavy-tailed) Distribution\") Example Results and Observations Uniform Distribution Sample means are approximately normal even for \\(n=10\\) . Very quick convergence to normality. Exponential Distribution Strongly skewed initially. Sample means show right-skew for small \\(n\\) , but become symmetric around \\(n \\geq 30\\) . Binomial Distribution Discrete distribution initially. Even small sample sizes ( \\(n=5\\) ) exhibit approximate normal behavior. Pareto Distribution Very heavy-tailed. Slow convergence; large sample sizes ( \\(n \\geq 50\\) ) needed for decent normal approximation. Analytical Discussion Rate of Convergence Faster for symmetric distributions (uniform, binomial). Slower for skewed/heavy-tailed distributions (exponential, Pareto). Variance Behavior Population variance \\(\\sigma^2\\) affects spread of sample mean distribution. Standard error decreases as: \\[ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} \\] Larger \\(n\\) \\(\\rightarrow\\) smaller spread of the sample mean distribution. Importance of Independence CLT assumes independent samples. Correlated data can violate assumptions and slow convergence. Practical Considerations CLT justifies use of z-tests and t-tests. Forms the theoretical backbone for bootstrap methods and confidence intervals. Key Takeaway : No matter the original population shape, the distribution of the sample mean becomes approximately normal as sample size increases, given finite variance and independence. Practical Applications of CLT Application Area Example Manufacturing Estimating mean product lifespan from samples Finance Predicting average returns of portfolios Medical Research Inferring population effects from clinical trial data Machine Learning Statistical bootstrapping and bagging Quality Control Monitoring production processes through sample means Epidemiology Estimating infection rates from health surveys Further Exploration Ideas Try extremely skewed distributions (e.g., Cauchy). Compare sample median versus sample mean behavior. Introduce correlation into samples to study breakdown of CLT assumptions. Explore the Generalized Central Limit Theorem for infinite variance distributions. Summary Through simulation, we've seen the Central Limit Theorem in action: Regardless of original population shape (uniform, exponential, binomial, Pareto), the sample mean distribution becomes approximately normal. Larger sample sizes yield better approximations. The CLT underpins most inferential statistical techniques. This computational experiment not only strengthens statistical intuition but also showcases why normality assumptions are reasonable in real-world data analysis, supporting decision-making across fields as diverse as manufacturing, finance, epidemiology, and machine learning.","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states: As the sample size increases, the sampling distribution of the sample mean approaches a normal distribution, regardless of the shape of the original population distribution (provided the population has finite mean and variance). Mathematically: If \\(X_1, X_2, ..., X_n\\) are independent and identically distributed random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then as \\(n \\to \\infty\\) , \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] where: - \\(\\bar{X}_n\\) = sample mean, - \\(\\xrightarrow{d}\\) denotes convergence in distribution, - \\(\\mathcal{N}(0, 1)\\) is the standard normal distribution. The CLT justifies the wide use of normal distribution approximations in inferential statistics. By simulating different sampling processes, we can visually and numerically observe this convergence!","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-outline","text":"","title":"Task Outline"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select three different population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each distribution: Generate a large \"population\" dataset of size \\(100,000\\) or more. Perform sampling of various sizes.","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each population: Draw random samples of size \\(n = 5, 10, 30, 50, 100\\) . Repeat the sampling 1000 times to build distributions of sample means. Plot histograms of the sample means. Overlay a normal curve for visual comparison. Observe convergence to normality.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Explore: Different population variances. How initial distribution shape affects convergence speed. Effect of sample size on variance of the sample mean.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Discuss: Estimation of parameters (means, proportions) from samples. Applications in manufacturing, finance, medicine, and machine learning.","title":"4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"A Markdown document and Python code that: Implements all simulations. Generates plots showing convergence. Includes comparison with true normal distribution. Visualizations of sampling distributions for each sample size. Discussion on: Connection to CLT. Impact of sample size and population variance.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use: NumPy for random number generation. Matplotlib and Seaborn for beautiful plots. SciPy for overlaying theoretical normal curves. Start simple (Uniform) before moving to complex distributions (Exponential, heavy-tailed). Ensure clear interpretation of sample means and histograms.","title":"Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/#full-python-code","text":"","title":"Full Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#define-sampling-function","text":"# Define parameters sample_sizes = [5, 10, 30, 50, 100] n_samples = 1000 # Number of repetitions # Helper function to perform sampling and plot results def simulate_sampling(population, pop_name): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(24, 5)) fig.suptitle(f'Sampling Distribution of Sample Means ({pop_name})', fontsize=18) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(n_samples): sample = np.random.choice(population, size=n, replace=True) sample_means.append(np.mean(sample)) # Plot histogram sns.histplot(sample_means, kde=False, ax=axes[i], stat=\"density\", color='skyblue', bins=30) # Fit and plot a normal curve mu, std = np.mean(sample_means), np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) axes[i].plot(x, norm.pdf(x, mu, std), 'r-', lw=2) axes[i].set_title(f'n = {n}') axes[i].set_xlabel('Sample Mean') axes[i].set_ylabel('Density') plt.tight_layout() plt.show()","title":"Define Sampling Function"},{"location":"1%20Physics/6%20Statistics/Problem_1/#generate-populations","text":"# Create large synthetic populations uniform_pop = np.random.uniform(0, 1, 100000) exponential_pop = np.random.exponential(scale=1, size=100000) binomial_pop = np.random.binomial(n=10, p=0.5, size=100000)","title":"Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#run-simulations","text":"simulate_sampling(uniform_pop, \"Uniform Distribution\") simulate_sampling(exponential_pop, \"Exponential Distribution\") simulate_sampling(binomial_pop, \"Binomial Distribution\")","title":"Run Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#additional-exploration-heavy-tailed-population","text":"# Pareto (heavy-tailed) distribution pareto_pop = (np.random.pareto(a=2, size=100000) + 1) * 2 simulate_sampling(pareto_pop, \"Pareto (Heavy-tailed) Distribution\")","title":"Additional Exploration: Heavy-Tailed Population"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-results-and-observations","text":"","title":"Example Results and Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"Sample means are approximately normal even for \\(n=10\\) . Very quick convergence to normality.","title":"Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"Strongly skewed initially. Sample means show right-skew for small \\(n\\) , but become symmetric around \\(n \\geq 30\\) .","title":"Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"Discrete distribution initially. Even small sample sizes ( \\(n=5\\) ) exhibit approximate normal behavior.","title":"Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#pareto-distribution","text":"Very heavy-tailed. Slow convergence; large sample sizes ( \\(n \\geq 50\\) ) needed for decent normal approximation.","title":"Pareto Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#analytical-discussion","text":"","title":"Analytical Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#rate-of-convergence","text":"Faster for symmetric distributions (uniform, binomial). Slower for skewed/heavy-tailed distributions (exponential, Pareto).","title":"Rate of Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_1/#variance-behavior","text":"Population variance \\(\\sigma^2\\) affects spread of sample mean distribution. Standard error decreases as: \\[ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} \\] Larger \\(n\\) \\(\\rightarrow\\) smaller spread of the sample mean distribution.","title":"Variance Behavior"},{"location":"1%20Physics/6%20Statistics/Problem_1/#importance-of-independence","text":"CLT assumes independent samples. Correlated data can violate assumptions and slow convergence.","title":"Importance of Independence"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-considerations","text":"CLT justifies use of z-tests and t-tests. Forms the theoretical backbone for bootstrap methods and confidence intervals. Key Takeaway : No matter the original population shape, the distribution of the sample mean becomes approximately normal as sample size increases, given finite variance and independence.","title":"Practical Considerations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications-of-clt","text":"Application Area Example Manufacturing Estimating mean product lifespan from samples Finance Predicting average returns of portfolios Medical Research Inferring population effects from clinical trial data Machine Learning Statistical bootstrapping and bagging Quality Control Monitoring production processes through sample means Epidemiology Estimating infection rates from health surveys","title":"Practical Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#further-exploration-ideas","text":"Try extremely skewed distributions (e.g., Cauchy). Compare sample median versus sample mean behavior. Introduce correlation into samples to study breakdown of CLT assumptions. Explore the Generalized Central Limit Theorem for infinite variance distributions.","title":"Further Exploration Ideas"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"Through simulation, we've seen the Central Limit Theorem in action: Regardless of original population shape (uniform, exponential, binomial, Pareto), the sample mean distribution becomes approximately normal. Larger sample sizes yield better approximations. The CLT underpins most inferential statistical techniques. This computational experiment not only strengthens statistical intuition but also showcases why normality assumptions are reasonable in real-world data analysis, supporting decision-making across fields as diverse as manufacturing, finance, epidemiology, and machine learning.","title":"Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi Using Monte Carlo Methods Motivation Monte Carlo simulations use randomness to solve problems that might be deterministic in principle. One fascinating application is estimating the value of \u03c0 (pi) \u2014 a fundamental mathematical constant \u2014 through geometric probability. This approach is powerful because: - It visually demonstrates probabilistic thinking. - It connects concepts from geometry, statistics, and computation. - It highlights convergence and randomness in numerical simulations. Part 1: Estimating \u03c0 Using a Circle (Geometric Probability) Theoretical Foundation Imagine a unit circle (radius = 1) inscribed in a square of side length 2. The area of the square is \\(( 4 )\\) and the area of the circle is \\(( \\pi )\\) . If we randomly throw darts at the square, the probability that a dart lands inside the circle is: \\[ P = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Hence, we can estimate \u03c0 as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside circle}}{\\text{Total points}} \\] Simulation in Python Estimate of \u03c0 with 100 points: 3.080000 Estimate of \u03c0 with 1000 points: 3.072000 Estimate of \u03c0 with 10000 points: 3.157200 Estimate of \u03c0 with 100000 points: 3.135560 Visualization Convergence Analysis Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Buffon's Needle is a probability experiment where a needle of length \\(( l )\\) is dropped onto a floor with parallel lines spaced distance \\(( d )\\) apart. If \\(( l \\leq d )\\) , then the probability that the needle crosses a line is: \\[ P = \\frac{2l}{d\\pi} \\] Rearranging gives the estimation of \u03c0: \\[ \\pi \\approx \\frac{2l \\times n}{d \\times \\text{number of crossings}} \\] Simulation in Python Estimate of \u03c0 with 100 throws: 3.571429 Estimate of \u03c0 with 1000 throws: 3.144654 Estimate of \u03c0 with 5000 throws: 3.184713 Estimate of \u03c0 with 10000 throws: 3.133323 Advanced Visualization (Optional Concept) Due to complexity in drawing angles and positions of each needle, this is usually left as conceptual or approximated with overlays. Comparison and Convergence Summary of Findings Circle-based method is simpler and converges faster with fewer points. Buffon\u2019s Needle is a clever historical method but requires more trials for good accuracy. Visualization and coding help in understanding random sampling, geometry, and convergence. Hints & Best Practices Use numpy for efficient random sampling. For Buffon\u2019s Needle, make sure the length of the needle does not exceed the line spacing. Start with small iterations to test and validate logic, then scale up.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating Pi Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations use randomness to solve problems that might be deterministic in principle. One fascinating application is estimating the value of \u03c0 (pi) \u2014 a fundamental mathematical constant \u2014 through geometric probability. This approach is powerful because: - It visually demonstrates probabilistic thinking. - It connects concepts from geometry, statistics, and computation. - It highlights convergence and randomness in numerical simulations.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle-geometric-probability","text":"","title":"Part 1: Estimating \u03c0 Using a Circle (Geometric Probability)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Imagine a unit circle (radius = 1) inscribed in a square of side length 2. The area of the square is \\(( 4 )\\) and the area of the circle is \\(( \\pi )\\) . If we randomly throw darts at the square, the probability that a dart lands inside the circle is: \\[ P = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Hence, we can estimate \u03c0 as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside circle}}{\\text{Total points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-in-python","text":"Estimate of \u03c0 with 100 points: 3.080000 Estimate of \u03c0 with 1000 points: 3.072000 Estimate of \u03c0 with 10000 points: 3.157200 Estimate of \u03c0 with 100000 points: 3.135560","title":"Simulation in Python"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle is a probability experiment where a needle of length \\(( l )\\) is dropped onto a floor with parallel lines spaced distance \\(( d )\\) apart. If \\(( l \\leq d )\\) , then the probability that the needle crosses a line is: \\[ P = \\frac{2l}{d\\pi} \\] Rearranging gives the estimation of \u03c0: \\[ \\pi \\approx \\frac{2l \\times n}{d \\times \\text{number of crossings}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-in-python_1","text":"Estimate of \u03c0 with 100 throws: 3.571429 Estimate of \u03c0 with 1000 throws: 3.144654 Estimate of \u03c0 with 5000 throws: 3.184713 Estimate of \u03c0 with 10000 throws: 3.133323","title":"Simulation in Python"},{"location":"1%20Physics/6%20Statistics/Problem_2/#advanced-visualization-optional-concept","text":"Due to complexity in drawing angles and positions of each needle, this is usually left as conceptual or approximated with overlays.","title":"Advanced Visualization (Optional Concept)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-and-convergence","text":"","title":"Comparison and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-of-findings","text":"Circle-based method is simpler and converges faster with fewer points. Buffon\u2019s Needle is a clever historical method but requires more trials for good accuracy. Visualization and coding help in understanding random sampling, geometry, and convergence.","title":"Summary of Findings"},{"location":"1%20Physics/6%20Statistics/Problem_2/#hints-best-practices","text":"Use numpy for efficient random sampling. For Buffon\u2019s Needle, make sure the length of the needle does not exceed the line spacing. Start with small iterations to test and validate logic, then scale up.","title":"Hints &amp; Best Practices"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Pendulum Experiment Report Setup Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight. Given: - Measured Length: $$ L = 1.000 \\, \\text{m} $$ - Ruler Resolution: $$ 0.001 \\, \\text{m} $$ - Uncertainty in length: $$ \\Delta L = \\frac{0.001}{2} = 0.0005 \\, \\text{m} $$ Data Collection Displace the pendulum slightly ( \\(<15^\\circ\\) ) and release. Measure the time for 10 oscillations. Measured times for 10 oscillations ( \\(T_{10}\\) ) (seconds): Trial \\(T_{10}\\) (s) 1 20.1 2 20.3 3 20.2 4 20.0 5 20.4 6 20.1 7 20.2 8 20.3 9 20.1 10 20.2 Mean time: $$ \\overline{T_{10}} = 20.19 \\, \\text{s} $$ Standard deviation: $$ \\sigma_T = 0.14 \\, \\text{s} $$ Uncertainty in the mean: $$ \\Delta T_{10} = \\frac{0.14}{\\sqrt{10}} = 0.044 \\, \\text{s} $$ Calculations 1. Calculate the Period Period of one oscillation: $$ T = \\frac{\\overline{T_{10}}}{10} = \\frac{20.19}{10} = 2.019 \\, \\text{s} $$ Uncertainty in the period: $$ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.044}{10} = 0.0044 \\, \\text{s} $$ 2. Determine Gravitational Acceleration Gravitational acceleration: $$ g = \\frac{4\\pi^2L}{T^2} $$ Substituting: $$ g = \\frac{4\\pi^2(1.000)}{(2.019)^2} $$ $$ g = \\frac{39.478}{4.076} = 9.684 \\, \\text{m/s}^2 $$ 3. Propagate Uncertainties Propagation formula: $$ \\Delta g = g \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\frac{\\Delta T}{T} \\right)^2 } $$ Substituting: $$ \\Delta g = 9.684 \\times \\sqrt{ \\left( \\frac{0.0005}{1.000} \\right)^2 + \\left( 2 \\times \\frac{0.0044}{2.019} \\right)^2 } $$ First, calculating inside the square root: $$ = \\sqrt{ (2.5\\times10^{-7}) + (9.6\\times10^{-6}) } $$ $$ = \\sqrt{9.85\\times10^{-6}} $$ $$ = 0.00314 $$ Thus: $$ \\Delta g = 9.684 \\times 0.00314 = 0.0304 \\, \\text{m/s}^2 $$ Final Results Length (L) = 1.0000 \u00b1 0.0005 m Mean time for 10 oscillations (T10_mean) = 20.190 \u00b1 0.038 s Period (T) = 2.0190 \u00b1 0.0038 s Gravitational acceleration (g) = 9.685 \u00b1 0.037 m/s\u00b2 Quantity Value Length ( \\(L\\) ) \\(1.000 \\pm 0.0005 \\, \\text{m}\\) Mean time for 10 oscillations ( \\(\\overline{T_{10}}\\) ) \\(20.19 \\pm 0.044 \\, \\text{s}\\) Period ( \\(T\\) ) \\(2.019 \\pm 0.0044 \\, \\text{s}\\) Gravitational acceleration ( \\(g\\) ) \\(9.684 \\pm 0.0304 \\, \\text{m/s}^2\\) Analysis The measured \\(g\\) ( \\(9.684 \\, \\text{m/s}^2\\) ) is slightly lower than the standard \\(9.81 \\, \\text{m/s}^2\\) , but within the uncertainty. Measurement resolution affects \\(\\Delta L\\) , which minimally affects \\(g\\) . Timing variability has a larger influence on the uncertainty \\(\\Delta T\\) , and therefore on \\(\\Delta g\\) . Assumptions: Small angle approximation ( \\(\\theta < 15^\\circ\\) ) holds. Negligible air resistance.","title":"Pendulum Experiment Report"},{"location":"1%20Physics/7%20Measurements/Problem_1/#pendulum-experiment-report","text":"","title":"Pendulum Experiment Report"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight. Given: - Measured Length: $$ L = 1.000 \\, \\text{m} $$ - Ruler Resolution: $$ 0.001 \\, \\text{m} $$ - Uncertainty in length: $$ \\Delta L = \\frac{0.001}{2} = 0.0005 \\, \\text{m} $$","title":"Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displace the pendulum slightly ( \\(<15^\\circ\\) ) and release. Measure the time for 10 oscillations. Measured times for 10 oscillations ( \\(T_{10}\\) ) (seconds): Trial \\(T_{10}\\) (s) 1 20.1 2 20.3 3 20.2 4 20.0 5 20.4 6 20.1 7 20.2 8 20.3 9 20.1 10 20.2 Mean time: $$ \\overline{T_{10}} = 20.19 \\, \\text{s} $$ Standard deviation: $$ \\sigma_T = 0.14 \\, \\text{s} $$ Uncertainty in the mean: $$ \\Delta T_{10} = \\frac{0.14}{\\sqrt{10}} = 0.044 \\, \\text{s} $$","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"Period of one oscillation: $$ T = \\frac{\\overline{T_{10}}}{10} = \\frac{20.19}{10} = 2.019 \\, \\text{s} $$ Uncertainty in the period: $$ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.044}{10} = 0.0044 \\, \\text{s} $$","title":"1. Calculate the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-gravitational-acceleration","text":"Gravitational acceleration: $$ g = \\frac{4\\pi^2L}{T^2} $$ Substituting: $$ g = \\frac{4\\pi^2(1.000)}{(2.019)^2} $$ $$ g = \\frac{39.478}{4.076} = 9.684 \\, \\text{m/s}^2 $$","title":"2. Determine Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"Propagation formula: $$ \\Delta g = g \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\frac{\\Delta T}{T} \\right)^2 } $$ Substituting: $$ \\Delta g = 9.684 \\times \\sqrt{ \\left( \\frac{0.0005}{1.000} \\right)^2 + \\left( 2 \\times \\frac{0.0044}{2.019} \\right)^2 } $$ First, calculating inside the square root: $$ = \\sqrt{ (2.5\\times10^{-7}) + (9.6\\times10^{-6}) } $$ $$ = \\sqrt{9.85\\times10^{-6}} $$ $$ = 0.00314 $$ Thus: $$ \\Delta g = 9.684 \\times 0.00314 = 0.0304 \\, \\text{m/s}^2 $$","title":"3. Propagate Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results","text":"Length (L) = 1.0000 \u00b1 0.0005 m Mean time for 10 oscillations (T10_mean) = 20.190 \u00b1 0.038 s Period (T) = 2.0190 \u00b1 0.0038 s Gravitational acceleration (g) = 9.685 \u00b1 0.037 m/s\u00b2 Quantity Value Length ( \\(L\\) ) \\(1.000 \\pm 0.0005 \\, \\text{m}\\) Mean time for 10 oscillations ( \\(\\overline{T_{10}}\\) ) \\(20.19 \\pm 0.044 \\, \\text{s}\\) Period ( \\(T\\) ) \\(2.019 \\pm 0.0044 \\, \\text{s}\\) Gravitational acceleration ( \\(g\\) ) \\(9.684 \\pm 0.0304 \\, \\text{m/s}^2\\)","title":"Final Results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"The measured \\(g\\) ( \\(9.684 \\, \\text{m/s}^2\\) ) is slightly lower than the standard \\(9.81 \\, \\text{m/s}^2\\) , but within the uncertainty. Measurement resolution affects \\(\\Delta L\\) , which minimally affects \\(g\\) . Timing variability has a larger influence on the uncertainty \\(\\Delta T\\) , and therefore on \\(\\Delta g\\) . Assumptions: Small angle approximation ( \\(\\theta < 15^\\circ\\) ) holds. Negligible air resistance.","title":"Analysis"}]}